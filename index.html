<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pikachu Adventure - OneGame Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- React & Babel for Single File Execution -->
    <script src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        :root {
            --primary-bg: #334155; 
            --text-main: #F1F5F9;
            --poke-red: #ef4444;
            --poke-blue: #3b82f6;
            --poke-yellow: #fbbf24;
            --poke-green: #10b981;
            --poke-dark: #1e293b;
            --poke-panel: #262e45;
        }

        body {
            font-family: 'Fredoka', 'Noto Sans TC', sans-serif;
            background-color: #0f172a; 
            color: var(--text-main);
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
        }

        .game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .phone-screen {
            width: 400px;
            height: 711px;
            background-color: var(--primary-bg);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
            flex-shrink: 0;
            overflow: hidden;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar { display: none; }

        .habby-shadow { box-shadow: 0 4px 0px rgba(0,0,0,0.25); }
        .habby-btn-shadow { box-shadow: 0 5px 0px rgba(0,0,0,0.3); }

        @keyframes walk {
            0%, 100% { transform: translateY(0) rotate(0); }
            50% { transform: translateY(-8px) rotate(3deg); }
        }
        .capy-walking-wrapper { animation: walk 0.6s infinite ease-in-out; }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        .floating-wrapper { animation: float 3s infinite ease-in-out; }

        @keyframes damage-pop {
            0% { opacity: 0; transform: translateY(0) scale(0.5); }
            20% { opacity: 1; transform: translateY(-20px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-40px) scale(1); }
        }
        .damage-number {
            animation: damage-pop 0.8s forwards;
            position: absolute;
            font-weight: 900;
            pointer-events: none;
            z-index: 50;
            text-shadow: 2px 2px 0 #000;
            white-space: nowrap;
        }

        @keyframes attack-right {
            0% { transform: translateX(0); }
            30% { transform: translateX(-10px); } 
            50% { transform: translateX(80px); } 
            100% { transform: translateX(0); }
        }
        @keyframes attack-left {
            0% { transform: translateX(0); }
            30% { transform: translateX(10px); }
            50% { transform: translateX(var(--attack-dist, -80px)); }
            100% { transform: translateX(0); }
        }
        
        @keyframes hit-shake {
            0% { transform: translate(0, 0); filter: brightness(1); }
            10% { transform: translate(-3px, -3px); filter: brightness(3) sepia(1) saturate(5) hue-rotate(-50deg); } 
            25% { transform: translate(3px, 2px); }
            40% { transform: translate(-2px, 3px); }
            55% { transform: translate(2px, -2px); filter: brightness(1); }
            70% { transform: translate(-1px, 1px); }
            85% { transform: translate(1px, -1px); }
            100% { transform: translate(0, 0); }
        }

        .animate-attack-right { animation: attack-right 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .animate-attack-left { animation: attack-left 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .animate-hit-shake { animation: hit-shake 0.4s ease-out; }

        @keyframes toast-in-out {
            0% { opacity: 0; transform: translate(-50%, -40%) scale(0.8); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -65%) scale(0.9); }
        }
        .obtained-toast {
            animation: toast-in-out 1.8s forwards;
            pointer-events: none;
        }

        .adventure-bg {
            background: linear-gradient(180deg, #7dd3fc 0%, #bae6fd 50%, #4ade80 50%, #22c55e 100%);
            position: relative;
            overflow: hidden;
        }
        
        .adventure-bg:before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(0,0,0,0.05) 100%);
            z-index: 2;
            pointer-events: none;
        }

        @keyframes parallax-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .scroll-clouds { animation: parallax-scroll 40s linear infinite; }
        .scroll-mountains { animation: parallax-scroll 20s linear infinite; }
        .scroll-ground { animation: parallax-scroll 2s linear infinite; }
        
        .paused {
            animation-play-state: paused;
        }

        .cloud {
            position: absolute;
            background: #fff;
            border-radius: 50px;
            opacity: 0.6;
            filter: blur(2px);
        }
        .cloud::after, .cloud::before {
            content: '';
            position: absolute;
            background: inherit;
            border-radius: 50%;
        }
        .cloud::after { width: 40px; height: 40px; top: -20px; left: 15px; }
        .cloud::before { width: 30px; height: 30px; top: -10px; left: 40px; }

        .mountain-container {
            position: absolute;
            bottom: 50%;
            width: 100%;
            height: 120px;
            pointer-events: none;
        }
        .mountain {
            position: absolute;
            bottom: 0;
            width: 0;
            height: 0;
            border-left: 60px solid transparent;
            border-right: 60px solid transparent;
            border-bottom: 80px solid #94a3b8;
            filter: drop-shadow(0 0 10px rgba(0,0,0,0.05));
            transform-origin: bottom center;
        }
        
        .stone {
            position: absolute;
            background-color: #78716c; 
            border-radius: 40% 60% 60% 40% / 40% 50% 50% 60%;
            opacity: 0.3;
        }

        .log-item {
            animation: fadeIn 0.2s ease-out forwards;
            will-change: transform, opacity;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .log-day-change {
            background: linear-gradient(90deg, rgba(30, 41, 59, 0) 0%, rgba(59, 130, 246, 0.15) 50%, rgba(30, 41, 59, 0) 100%);
            border-top: 1px solid rgba(59, 130, 246, 0.3);
            border-bottom: 1px solid rgba(59, 130, 246, 0.3);
            text-align: center;
            color: #60a5fa !important;
            padding: 8px 0;
            margin: 6px 0;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            animation: fadeIn 0.5s ease-out;
            font-style: italic;
            letter-spacing: 0.05em;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.15);
        }

        @keyframes resume-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 15px rgba(251, 191, 36, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); }
        }
        .resume-btn-anim {
            animation: resume-pulse 2s infinite ease-in-out;
        }
        
        @keyframes chest-shake {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
            75% { transform: rotate(-5deg); }
            100% { transform: rotate(0deg); }
        }
        .chest-anim { animation: chest-shake 0.5s infinite; }
        
        @keyframes popup-bounce {
            0% { transform: translateX(-50%) scale(0.8) translateY(10px); opacity: 0; }
            100% { transform: translateX(-50%) scale(1) translateY(0); opacity: 1; }
        }
        .popup-menu { animation: popup-bounce 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

        @keyframes border-breathe {
            0%, 100% { border-color: #4ade80; box-shadow: 0 0 5px rgba(74, 222, 128, 0.4); }
            50% { border-color: #22c55e; box-shadow: 0 0 15px rgba(74, 222, 128, 0.9); }
        }
        .active-slot-anim {
            animation: border-breathe 2s infinite ease-in-out;
        }

        @keyframes new-item-breathe {
            0%, 100% { border-color: #ef4444; box-shadow: 0 0 5px rgba(239, 68, 68, 0.4); }
            50% { border-color: #b91c1c; box-shadow: 0 0 15px rgba(220, 38, 38, 0.9); }
        }
        .new-item-anim { animation: new-item-breathe 1.5s infinite ease-in-out; }
        
        @keyframes red-flash {
            0% { box-shadow: 0 0 0 rgba(239, 68, 68, 0); border-color: #ef4444; }
            10% { box-shadow: 0 0 25px rgba(239, 68, 68, 0.9); border-color: #ef4444; transform: scale(1.05); }
            100% { box-shadow: 0 0 0 rgba(239, 68, 68, 0); border-color: inherit; transform: scale(1); }
        }
        .equip-highlight-red {
            animation: red-flash 2s ease-out forwards;
            z-index: 50 !important;
            border-color: #ef4444 !important;
        }

        .poke-panel {
            background-color: #1e293b;
            border-color: #334155;
        }
        
        .btn-poke-red {
            background-color: #ef4444;
            border: 2px solid #b91c1c;
            color: white;
        }
        .btn-poke-red:hover { background-color: #dc2626; }
        
        .btn-poke-green {
            background-color: #10b981;
            border: 2px solid #059669;
            color: white;
        }
        .btn-poke-green:hover { background-color: #059669; }

        .btn-poke-blue {
            background-color: #3b82f6;
            border: 2px solid #1d4ed8;
            color: white;
        }
        .btn-poke-blue:hover { background-color: #2563eb; }
        
        .btn-poke-yellow {
            background-color: #f59e0b;
            border: 2px solid #b45309;
            color: white;
        }
        .btn-poke-yellow:hover { background-color: #d97706; }

        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react, typescript">
        const { useState, useEffect, useRef, useMemo } = React;

        // ==================== CONSTANTS ====================
        const VERSION = "v3.60.9 (OneGame)";

        const CHANGE_LOGS = [
            {
            ver: "v3.60.9",
            date: "2026-01-10 18:45",
            changes: [
                "‰ªãÈù¢ÔºöÈáçÊßã‰∏ªÈÅ∏ÂñÆ‰ΩàÂ±ÄÔºåÁ¢∫‰øù„ÄåÂ≠òÊ™îÁÆ°ÁêÜ„ÄçËàá„ÄåÈñãÂßãÈÅäÊà≤„ÄçÊåâÈàïÂú®ÊâÄÊúâËß£ÊûêÂ∫¶‰∏ãÁöÜÊ∏ÖÊô∞ÂèØË¶ã„ÄÇ",
                "ÂÑ™ÂåñÔºöË™øÊï¥Êõ¥Êñ∞Êó•Ë™åÈ°ØÁ§∫ÂçÄÂüüÔºåÈÅøÂÖçÈÅÆÊìãÈáçË¶ÅÂäüËÉΩÊåâÈàï„ÄÇ",
            ]
            },
            {
            ver: "v3.60.8",
            date: "2026-01-10 18:30",
            changes: [
                "‰øÆÊ≠£Ôºö‰øÆÂæ©ÂñÆÊ©üÁâà (HTML) Âú®ÁÄèË¶ΩÂô®ÈôêÂà∂‰∏ãÁÑ°Ê≥ïÂ≠òÊ™îÁöÑÂïèÈ°å„ÄÇ",
                "ÂäüËÉΩÔºöÊñ∞Â¢ûÂ≠òÊ™îÂ§±ÊïóÊôÇËá™ÂãïÂºïÂ∞éÊ™îÊ°à‰∏ãËºâÊ©üÂà∂ÔºåÁ¢∫‰øùÈÄ≤Â∫¶‰∏ç‰∏üÂ§±„ÄÇ",
            ]
            }
        ];

        const ENEMIES_DATA = [
            { name: "ÁôæËÆäÊÄ™", icon: "132", hp: 45, atk: 8, def: 2, evade: 0.02, rank: 0 },
            { name: "Â∞èÊãâÈÅî", icon: "19", hp: 35, atk: 7, def: 1, evade: 0.02, rank: 0 },
            { name: "ÂñµÂñµ", icon: "52", hp: 40, atk: 8, def: 1, evade: 0.02, rank: 0 },
            { name: "Ë∂ÖÈü≥Ëù†", icon: "41", hp: 30, atk: 9, def: 0, evade: 0.05, rank: 0 },
            { name: "È¨ºÊñØ", icon: "92", hp: 25, atk: 12, def: 0, evade: 0.08, rank: 0 },
            { name: "ÈØâÈ≠öÁéã", icon: "129", hp: 20, atk: 5, def: 0, evade: 0.0, rank: 0 },
            { name: "ÂèØÈÅîÈ¥®", icon: "54", hp: 50, atk: 8, def: 3, evade: 0.01, rank: 0 },
            { name: "Áå¥ÊÄ™", icon: "56", hp: 45, atk: 11, def: 2, evade: 0.03, rank: 0 },
            
            { name: "ÁÅ´ÁàÜÁå¥", icon: "57", hp: 120, atk: 18, def: 8, evade: 0.05, rank: 1 },
            { name: "ÈªëÈ≠ØÂä†", icon: "229", hp: 180, atk: 22, def: 10, evade: 0.05, rank: 1 },
            { name: "Â§ßÂ≤©Ëõá", icon: "95", hp: 250, atk: 15, def: 25, evade: 0.0, rank: 1 },
            { name: "È£õÂ§©Ëû≥ËûÇ", icon: "123", hp: 140, atk: 30, def: 5, evade: 0.10, rank: 1 },
            { name: "ËÄøÈ¨º", icon: "94", hp: 160, atk: 28, def: 5, evade: 0.15, rank: 1 },
            { name: "ÊÄ™Âäõ", icon: "68", hp: 200, atk: 25, def: 12, evade: 0.02, rank: 1 },
            { name: "È¢®ÈÄüÁãó", icon: "59", hp: 190, atk: 24, def: 10, evade: 0.06, rank: 1 },

            { name: "Âô¥ÁÅ´Èæç", icon: "6", hp: 450, atk: 40, def: 18, evade: 0.05, rank: 2 },
            { name: "Âø´Èæç", icon: "149", hp: 600, atk: 45, def: 25, evade: 0.05, rank: 2 },
            { name: "Êö¥ÈØâÈæç", icon: "130", hp: 550, atk: 48, def: 20, evade: 0.03, rank: 2 },
            { name: "Âç°ÊØîÁç∏", icon: "143", hp: 800, atk: 35, def: 30, evade: 0.0, rank: 2 },
            { name: "Áè≠Âü∫ÊãâÊñØ", icon: "248", hp: 700, atk: 50, def: 40, evade: 0.02, rank: 2 }
        ];

        const ITEM_POOL = [
            { id: 'item_w1', name: "ÈèΩË∑°Êú®Âäç", slot: "weapon", atk: 5, icon: "Sword", rarity: "Common", price: 100 },
            { id: 'item_w2', name: "Á≤æÈãºÈï∑Âäç", slot: "weapon", atk: 18, icon: "Sword", rarity: "Rare", price: 300 },
            { id: 'item_w3', name: "ÂãáËÄÖ‰πãÂäç", slot: "weapon", atk: 35, icon: "Sword", rarity: "Legendary", price: 800 },
            { id: 'item_w4', name: "Èõ∑ÈúÜÊà∞Èåò", slot: "weapon", atk: 25, icon: "Hammer", rarity: "Rare", price: 400 },
            { id: 'item_b1', name: "Á†¥ËàäÁöÆÁî≤", slot: "body", def: 3, icon: "Shirt", rarity: "Common", price: 100 },
            { id: 'item_b2', name: "ÂÜíÈö™ËÄÖËÉ∏Áî≤", slot: "body", def: 12, icon: "Shirt", rarity: "Rare", price: 350 },
            { id: 'item_b3', name: "ÁßòÈäÄÈéßÁî≤", slot: "body", def: 25, icon: "Shirt", rarity: "Legendary", price: 900 },
            { id: 'item_b4', name: "ÊöóÂΩ±Êä´È¢®", slot: "body", def: 8, evade: 0.05, icon: "Shirt", rarity: "Rare", price: 400 },
            { id: 'item_h1', name: "Á†¥ÊêçËçâÂ∏Ω", slot: "head", def: 2, icon: "Crown", rarity: "Common", price: 80 },
            { id: 'item_h2', name: "È®éÂ£´È†≠Áõî", slot: "head", def: 8, icon: "Crown", rarity: "Rare", price: 280 },
            { id: 'item_h3', name: "ÈæçÈ±óÊà∞Áõî", slot: "head", def: 18, icon: "Crown", rarity: "Legendary", price: 750 },
            { id: 'item_r1', name: "ÈäÖË£ΩÊàíÊåá", slot: "ring", atk: 3, icon: "Gem", rarity: "Common", price: 120 },
            { id: 'item_r2', name: "ÂäõÈáèÊåáÁí∞", slot: "ring", atk: 10, icon: "Gem", rarity: "Rare", price: 350 },
            { id: 'item_t1', name: "Âπ∏ÈÅãË≠∑Á¨¶", slot: "trinket", hp: 50, icon: "Zap", rarity: "Rare", price: 400 },
            { id: 'item_t2', name: "Â§©‰ΩøÈ†ÖÈçä", slot: "trinket", hp: 150, icon: "Zap", rarity: "Legendary", price: 800 },
            { id: 'item_s1', name: "Â∏ÉÂ∫ïÈûã", slot: "shoes", def: 1, icon: "Footprints", rarity: "Common", price: 80 },
            { id: 'item_s2', name: "ËøÖÊç∑‰πãÈù¥", slot: "shoes", def: 4, evade: 0.03, icon: "Footprints", rarity: "Rare", price: 300 },
            { id: 'item_s3', name: "ÈáçË£ùÊà∞Èù¥", slot: "shoes", def: 10, icon: "Footprints", rarity: "Rare", price: 350 }
        ];

        const ACHIEVEMENT_CATEGORIES = {
            combat: "‚öîÔ∏è Êà∞È¨•Â§ßÂ∏´",
            adventure: "üå≤ ÂÜíÈö™ÁîüÂ≠ò",
            wealth: "üí∞ Ë≤°ÂØåÂ§ß‰∫®",
            growth: "üî® ÈçõÈÄ†ËÅ∑‰∫∫"
        };

        const ACHIEVEMENTS = [
            { id: 'kill_10', category: 'combat', target: 10, title: 'Ë¶ãÁøíÁçµ‰∫∫', desc: 'Á¥ØË®àÊìäÊïó 10 ÈöªÊïµ‰∫∫', buff: { atk: 2 }, buffDesc: 'ÊîªÊìä+2' },
            { id: 'kill_50', category: 'combat', target: 50, title: 'Êà∞È¨•Â∞àÂÆ∂', desc: 'Á¥ØË®àÊìäÊïó 50 ÈöªÊïµ‰∫∫', buff: { atk: 5 }, buffDesc: 'ÊîªÊìä+5' },
            { id: 'kill_100', category: 'combat', target: 100, title: 'Áôæ‰∫∫Êñ¨', desc: 'Á¥ØË®àÊìäÊïó 100 ÈöªÊïµ‰∫∫', buff: { atk: 10 }, buffDesc: 'ÊîªÊìä+10' },
            { id: 'kill_500', category: 'combat', target: 500, title: 'Êà∞Â†¥‰øÆÁæÖ', desc: 'Á¥ØË®àÊìäÊïó 500 ÈöªÊïµ‰∫∫', buff: { atk: 25 }, buffDesc: 'ÊîªÊìä+25' },
            { id: 'kill_1000', category: 'combat', target: 1000, title: 'ÂÇ≥Ë™™ÂãáËÄÖ', desc: 'Á¥ØË®àÊìäÊïó 1000 ÈöªÊïµ‰∫∫', buff: { atk: 50 }, buffDesc: 'ÊîªÊìä+50' },
            { id: 'kill_2000', category: 'combat', target: 2000, title: '‰∏çÊúΩÂÇ≥Â•á', desc: 'Á¥ØË®àÊìäÊïó 2000 ÈöªÊïµ‰∫∫', buff: { atk: 80, crit: 0.05 }, buffDesc: 'ÊîªÊìä+80, Êö¥Êìä+5%' },
            { id: 'kill_5000', category: 'combat', target: 5000, title: 'Êà∞Á•û', desc: 'Á¥ØË®àÊìäÊïó 5000 ÈöªÊïµ‰∫∫', buff: { atk: 150, crit: 0.1 }, buffDesc: 'ÊîªÊìä+150, Êö¥Êìä+10%' },
            { id: 'day_10', category: 'adventure', target: 10, title: 'Èú≤ÁáüÊÑõÂ•ΩËÄÖ', desc: 'Á¥ØË®àÂ≠òÊ¥ª 10 Â§©', buff: { hp: 20 }, buffDesc: 'ÁîüÂëΩ+20' },
            { id: 'day_50', category: 'adventure', target: 50, title: 'ËçíÈáéÊ±ÇÁîü', desc: 'Á¥ØË®àÂ≠òÊ¥ª 50 Â§©', buff: { hp: 50 }, buffDesc: 'ÁîüÂëΩ+50' },
            { id: 'day_100', category: 'adventure', target: 100, title: 'ÂÇ≥Â•áÂÜíÈö™ÂÆ∂', desc: 'Á¥ØË®àÂ≠òÊ¥ª 100 Â§©', buff: { hp: 100, def: 5 }, buffDesc: 'ÁîüÂëΩ+100, Èò≤Á¶¶+5' },
            { id: 'day_200', category: 'adventure', target: 200, title: 'Ê∞∏ÊÅÜË°åËÄÖ', desc: 'Á¥ØË®àÂ≠òÊ¥ª 200 Â§©', buff: { hp: 200, def: 10 }, buffDesc: 'ÁîüÂëΩ+200, Èò≤Á¶¶+10' },
            { id: 'day_365', category: 'adventure', target: 365, title: 'Ê≠≤ÊúàË¶ãË≠âËÄÖ', desc: 'Á¥ØË®àÂ≠òÊ¥ª 365 Â§©', buff: { hp: 500, def: 20 }, buffDesc: 'ÁîüÂëΩ+500, Èò≤Á¶¶+20' },
            { id: 'day_500', category: 'adventure', target: 500, title: 'ÊôÇÂÖâÈ†ò‰∏ª', desc: 'Á¥ØË®àÂ≠òÊ¥ª 500 Â§©', buff: { hp: 1000, def: 50 }, buffDesc: 'ÁîüÂëΩ+1000, Èò≤Á¶¶+50' },
            { id: 'gold_2000', category: 'wealth', target: 2000, title: 'Á¨¨‰∏ÄÊ°∂Èáë', desc: 'Á¥ØË®àÁç≤Âæó 2000 ÈáëÂπ£', buff: { hp: 10 }, buffDesc: 'ÁîüÂëΩ+10' },
            { id: 'gold_10000', category: 'wealth', target: 10000, title: 'ÊèÆÈáëÂ¶ÇÂúü', desc: 'Á¥ØË®àÁç≤Âæó 10000 ÈáëÂπ£', buff: { hp: 30 }, buffDesc: 'ÁîüÂëΩ+30' },
            { id: 'gold_50000', category: 'wealth', target: 50000, title: 'ÂØåÂèØÊïµÂúã', desc: 'Á¥ØË®àÁç≤Âæó 50000 ÈáëÂπ£', buff: { hp: 50 }, buffDesc: 'ÁîüÂëΩ+50' },
            { id: 'gold_100000', category: 'wealth', target: 100000, title: 'Ë≤°ÂØåÊ¶úÈ¶ñ', desc: 'Á¥ØË®àÁç≤Âæó 10Ëê¨ ÈáëÂπ£', buff: { hp: 100, evade: 0.02 }, buffDesc: 'ÁîüÂëΩ+100, ÈñÉÈÅø+2%' },
            { id: 'gold_500000', category: 'wealth', target: 500000, title: 'ÈáëÂπ£‰πãÁéã', desc: 'Á¥ØË®àÁç≤Âæó 50Ëê¨ ÈáëÂπ£', buff: { hp: 300, evade: 0.05 }, buffDesc: 'ÁîüÂëΩ+300, ÈñÉÈÅø+5%' },
            { id: 'gold_1000000', category: 'wealth', target: 1000000, title: 'Ë≤°Á•ûÁà∫', desc: 'Á¥ØË®àÁç≤Âæó 100Ëê¨ ÈáëÂπ£', buff: { hp: 800, evade: 0.1 }, buffDesc: 'ÁîüÂëΩ+800, ÈñÉÈÅø+10%' },
            { id: 'upgrade_10', category: 'growth', target: 10, title: 'Êï≤Êï≤ÊâìÊâì', desc: 'Á¥ØË®àÂº∑ÂåñË£ùÂÇô 10 Ê¨°', buff: { def: 2 }, buffDesc: 'Èò≤Á¶¶+2' },
            { id: 'upgrade_50', category: 'growth', target: 50, title: 'Á•ûÂå†Â∑•Ëóù', desc: 'Á¥ØË®àÂº∑ÂåñË£ùÂÇô 50 Ê¨°', buff: { def: 10 }, buffDesc: 'Èò≤Á¶¶+10' },
            { id: 'upgrade_100', category: 'growth', target: 100, title: 'ÈçõÈÄ†Â§ßÂ∏´', desc: 'Á¥ØË®àÂº∑ÂåñË£ùÂÇô 100 Ê¨°', buff: { def: 20 }, buffDesc: 'Èò≤Á¶¶+20' },
            { id: 'upgrade_200', category: 'growth', target: 200, title: 'ÂÇ≥Ë™™ÈêµÂå†', desc: 'Á¥ØË®àÂº∑ÂåñË£ùÂÇô 200 Ê¨°', buff: { def: 50 }, buffDesc: 'Èò≤Á¶¶+50' },
            { id: 'upgrade_500', category: 'growth', target: 500, title: 'Á•û‰πãÊâã', desc: 'Á¥ØË®àÂº∑ÂåñË£ùÂÇô 500 Ê¨°', buff: { def: 100, atk: 50 }, buffDesc: 'Èò≤Á¶¶+100, ÊîªÊìä+50' },
        ];

        const SLOT_MAP = {
            weapon: 'Ê≠¶Âô®', head: 'È†≠ÈÉ®', body: 'Ë∫´È´î', 
            shoes: 'ÈûãÂ≠ê', ring: 'ÊàíÊåá', trinket: 'Ë≠∑Á¨¶'
        };

        const AOE_EFFECT = {
            type: 'aoe',
            name: "ÂÖ®È´îÊîªÊìä",
            desc: "ÊîªÊìäÊúâÊ©üÁéáÊìä‰∏≠ÊâÄÊúâÊïµ‰∫∫",
            getDesc: (lvl, val) => `ÊôÆÈÄöÊîªÊìä ${Math.round((val||0.7)*100)}% Ê©üÁéáÊìä‰∏≠ÊâÄÊúâÊïµ‰∫∫`,
            icon: "Swords",
            color: "text-purple-300",
            exclusive: true
        };

        const WEAPON_EFFECTS = [
            { 
                type: 'paralyze', 
                name: "È∫ªÁó∫", 
                desc: "ÊîªÊìäÊúâÊ©üÁéáÈ∫ªÁó∫Êïµ‰∫∫",
                getDesc: (lvl, val) => `ÊîªÊìäÊôÇ ${Math.round((val||0.2)*100)}% Ê©üÁéáÈ∫ªÁó∫Êïµ‰∫∫ 1 ÂõûÂêà`,
                icon: "Zap", 
                color: "text-yellow-300"
            },
            { 
                type: 'fire', 
                name: "ÁáÉÁáí", 
                desc: "ÊîªÊìäÊúâÊ©üÁéáÁáÉÁáíÊïµ‰∫∫",
                getDesc: (lvl, val) => `ÊîªÊìäÊôÇ ${Math.round((val||0.25)*100)}% Ê©üÁéáÁáÉÁáíÊïµ‰∫∫ 3 ÂõûÂêà`, 
                icon: "Flame", 
                color: "text-orange-300"
            },
            { 
                type: 'vampire', 
                name: "Âê∏Ë°Ä", 
                desc: "ÊîªÊìäÊúâÊ©üÁéáÂê∏Ë°Ä",
                getDesc: (lvl, val) => `ÊîªÊìäÊôÇ ${Math.round((val||0.35)*100)}% Ê©üÁéáÂê∏Âèñ 10% ÂÇ∑ÂÆ≥ÁÇ∫ÁîüÂëΩ`, 
                icon: "Droplet", 
                color: "text-red-300"
            },
            { 
                type: 'regen', 
                name: "ÂõûÊò•", 
                desc: "ÂõûÂêàÈñãÂßãÊ©üÁéáÊÅ¢Âæ©ÁîüÂëΩ",
                getDesc: (lvl, val) => `ÊØèÂõûÂêà ${Math.round((val||0.35)*100)}% Ê©üÁéáÊÅ¢Âæ© 5% ÊúÄÂ§ßÁîüÂëΩ`,
                icon: "HeartPulse", 
                color: "text-emerald-300"
            },
            { 
                type: 'counter', 
                name: "ÂèçÊìä", 
                desc: "ÂèóÊìäÊúâÊ©üÁéáÂèçÊìä",
                getDesc: (lvl, val) => `ÂèóÊìäÊôÇ ${Math.round((val||0.2)*100)}% Ê©üÁéáÂèçÊìä 80% ÂÇ∑ÂÆ≥`,
                icon: "Swords", 
                color: "text-indigo-300"
            },
            { 
                type: 'weakness', 
                name: "ËôõÂº±", 
                desc: "ÊîªÊìäÊúâÊ©üÁéáËôõÂº±Êïµ‰∫∫",
                getDesc: (lvl, val) => `ÊîªÊìäÊôÇ ${Math.round((val||0.15)*100)}% Ê©üÁéáËôõÂº±Êïµ‰∫∫ 2 ÂõûÂêà`,
                icon: "Skull", 
                color: "text-slate-400"
            }
        ];

        const SHOP_ITEMS = [
            { id: 'shop_1', name: "Â§ßÁì∂ÁîüÂëΩËó•Ê∞¥", price: 150, desc: "Ë≥ºË≤∑ÂæåÂ≠òÂÖ•Ë£úË°ÄÁΩê", icon: "Coffee", type: "consumable" },
            { id: 'shop_6', name: "È∫ªÁó∫Ëó•Ê∞¥", price: 250, desc: "Êà∞È¨•‰∏≠‰ΩøÁî®ÔºåÈ∫ªÁó∫Êïµ‰∫∫ 2 ÂõûÂêà", icon: "Zap", type: "consumable" },
            { id: 'shop_7', name: "ÈÄ£ÊìäËó•Ê∞¥", price: 300, desc: "Êà∞È¨•‰∏≠‰ΩøÁî®Ôºå2ÂõûÂêàÂÖßÊîªÊìä2Ê¨°", icon: "Swords", type: "consumable" },
            { id: 'shop_3', name: "Á•ûÁßòË£ùÂÇôÁÆ±", price: 400, desc: "Èö®Ê©üÁç≤Âæó‰∏Ä‰ª∂Ë£ùÂÇô", icon: "Box", type: "chest", chestType: "random" },
            { id: 'shop_weapon', name: "ÂãáËÄÖÊ≠¶Âô®ÁÆ±", price: 500, desc: "Èö®Ê©üÁç≤Âæó‰∏Ä‰ª∂Ê≠¶Âô®", icon: "Sword", type: "chest", chestType: "weapon" },
            { id: 'shop_armor', name: "Â†ÖÈüåÈò≤ÂÖ∑ÁÆ±", price: 350, desc: "Èö®Ê©üÁç≤Âæó‰∏Ä‰ª∂Èò≤ÂÖ∑ (È†≠/Ë∫´/ËÖ≥)", icon: "Shield", type: "chest", chestType: "armor" },
            { id: 'shop_acc', name: "ÈñÉËÄÄÈ£æÂìÅÁÆ±", price: 400, desc: "Èö®Ê©üÁç≤Âæó‰∏Ä‰ª∂È£æÂìÅ", icon: "Gem", type: "chest", chestType: "accessory" }
        ];

        const BACKGROUNDS = ['sky_mountain_grass', 'desert_mode', 'cave_mode'];
        const POINTS_PER_LEVEL = 3;

        // ==================== HELPERS ====================
        const generateId = () => Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
        const getRarityColor = (r) => r === 'Legendary' ? 'text-amber-400' : r === 'Rare' ? 'text-blue-400' : 'text-slate-200';
        const formatGold = (num) => num >= 10000 ? (Math.floor(num / 1000)) + 'K' : num;
        const getExpReq = (level) => Math.floor(150 * level);
        
        const getItemStats = (item) => {
            const lvl = item.level || 1;
            const multiplier = 1 + (lvl - 1) * 0.15; 
            return {
                atk: item.atk ? Math.floor(item.atk * multiplier) : 0,
                def: item.def ? Math.floor(item.def * multiplier) : 0,
                hp: item.hp ? Math.floor(item.hp * multiplier) : 0,
                evade: item.evade || 0 
            };
        };

        const getEffectChance = (type) => {
            switch(type) {
                case 'aoe': return 0.6 + Math.random() * 0.2; 
                case 'counter': return 0.15 + Math.random() * 0.1;
                case 'weakness': return 0.1 + Math.random() * 0.1;
                case 'fire': return 0.2 + Math.random() * 0.1;
                case 'paralyze': return 0.15 + Math.random() * 0.1;
                case 'vampire': return 0.3 + Math.random() * 0.1;
                case 'regen': return 0.3 + Math.random() * 0.1;
                default: return 0.1;
            }
        };

        const getEffectDesc = (effectOrType, level = 1) => {
            const type = typeof effectOrType === 'string' ? effectOrType : effectOrType.type;
            const effectObj = typeof effectOrType === 'object' ? effectOrType : null;
            if (type === 'crit_burst' && effectObj) return `Êö¥ÊìäÁéá +${((effectObj.val || 0) * 100).toFixed(1)}%`;
            if (type === 'evade_phantom' && effectObj) return `ÈñÉÈÅøÁéá +${((effectObj.val || 0) * 100).toFixed(1)}%`;
            if (type === 'aoe') {
                const val = effectObj && effectObj.val ? effectObj.val : 0.7;
                return AOE_EFFECT.getDesc ? AOE_EFFECT.getDesc(level, val) : '';
            }
            const def = WEAPON_EFFECTS.find(e => e.type === type);
            if (def && def.getDesc) {
                const val = effectObj && effectObj.val ? effectObj.val : 0.2;
                return def.getDesc(level, val);
            }
            return "Êú™Áü•ÊïàÊûú";
        };

        const addRandomEffects = (item, count = 1, isLegendary = false) => {
            const newEffects = item.effects ? [...item.effects] : [];
            if (item.slot === 'ring') {
                if (!newEffects.some(e => e.type === 'crit_burst')) {
                    if (Math.random() < 0.5 || isLegendary) {
                        const val = 0.20 + Math.random() * 0.15; 
                        newEffects.push({ type: 'crit_burst', name: 'ÁàÜÁôº', val: val, color: 'text-pink-400', icon: 'Target' });
                        count--; 
                    }
                }
            } else if (item.slot === 'shoes') {
                if (!newEffects.some(e => e.type === 'evade_phantom')) {
                    if (Math.random() < 0.5 || isLegendary) {
                        const val = 0.20 + Math.random() * 0.15; 
                        newEffects.push({ type: 'evade_phantom', name: 'ÂπªÂΩ±', val: val, color: 'text-cyan-400', icon: 'Wind' });
                        count--; 
                    }
                }
            }
            const generalEffectSlots = ['weapon', 'trinket', 'ring', 'shoes', 'head', 'body'];
            if (!isLegendary && !generalEffectSlots.includes(item.slot)) return item;
            if (isLegendary) {
                if (Math.random() < 0.3) {
                    if (!newEffects.some(e => e.type === 'aoe') && (item.slot === 'weapon' || item.slot === 'trinket')) {
                        const val = getEffectChance('aoe');
                        newEffects.push({ ...AOE_EFFECT, val });
                        count--; 
                    }
                }
            }
            if (generalEffectSlots.includes(item.slot)) {
                for (let i = 0; i < count; i++) {
                    const availableEffects = WEAPON_EFFECTS.filter(e => !newEffects.some(existing => existing.type === e.type));
                    if (availableEffects.length > 0) {
                        const baseEffect = availableEffects[Math.floor(Math.random() * availableEffects.length)];
                        const val = getEffectChance(baseEffect.type);
                        newEffects.push({ ...baseEffect, val });
                    }
                }
            }
            return { ...item, effects: newEffects };
        };

        const generateScaledItem = (baseItem, day, playerLevel, isBossDrop = false) => {
            const item = { ...baseItem, uid: generateId(), exp: 0, effects: [] };
            let calculatedLevel = 1 + Math.floor(day / 8);
            const maxLevelAllowed = Math.max(1, Math.floor(playerLevel / 2));
            item.level = Math.min(calculatedLevel, maxLevelAllowed);
            const rand = Math.random();
            const legendaryChance = isBossDrop ? 0.15 : 0.005; 
            const rareChance = Math.min(0.8, 0.1 + (day * 0.02));
            if (rand < legendaryChance) {
                item.rarity = 'Legendary';
                if (item.atk) item.atk = Math.floor(item.atk * 1.5);
                if (item.def) item.def = Math.floor(item.def * 1.5);
                if (item.hp) item.hp = Math.floor(item.hp * 1.5);
                return addRandomEffects(item, 2, true);
            } else if (isBossDrop || rand < rareChance) {
                item.rarity = 'Rare';
                if (item.atk) item.atk = Math.floor(item.atk * 1.25);
                if (item.def) item.def = Math.floor(item.def * 1.25);
                if (item.hp) item.hp = Math.floor(item.hp * 1.25);
                if (isBossDrop || Math.random() < 0.6) {
                    return addRandomEffects(item, 1, false);
                }
            } else {
                item.rarity = 'Common';
                if (Math.random() < 0.1) {
                    return addRandomEffects(item, 1, false);
                }
            }
            return item;
        };

        const getFodderExp = (item, targetSlot) => {
            let base = item.rarity === 'Legendary' ? 400 : item.rarity === 'Rare' ? 150 : 50;
            if (item.effects && item.effects.length > 0) base = Math.floor(base * 1.5);
            else if (item.effect) base = Math.floor(base * 1.5); 
            let investedExp = 0;
            const currentLevel = item.level || 1;
            for (let i = 1; i < currentLevel; i++) {
                investedExp += getExpReq(i);
            }
            investedExp += (item.exp || 0);
            let total = base + Math.floor(investedExp * 0.8);
            if (targetSlot && item.slot !== targetSlot) {
                total = Math.floor(total * 0.7);
            }
            return total;
        };

        const sleep = (ms) => new Promise(r => setTimeout(r, ms));
        const safeLocalStorage = {
            getItem: (key) => { try { return localStorage.getItem(key); } catch (e) { return null; } },
            setItem: (key, value) => { try { localStorage.setItem(key, value); return true; } catch (e) { return false; } },
            removeItem: (key) => { try { localStorage.removeItem(key); return true; } catch (e) { return false; } }
        };

        // ==================== COMPONENTS ====================

        const Icon = ({ name, size = 24, className = "" }) => {
            const icons = {
                Swords: <path d="m14.5 17.5-2.5 2.5-10-10 2.5-2.5m10 10 7 7m-7-7-10-10M5.5 8.5l7 7m-3.5-3.5 10-10 2.5 2.5-10 10-2.5-2.5m10-10-7 7m7-7 10 10" />,
                CrossedSwords: <g><path d="m2 2 20 20"/><path d="m22 2-20 20"/></g>, 
                Box: <path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" />,
                Sparkles: <path d="M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.937A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 0 .962L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.962 0z" />,
                Coins: <g><circle cx="12" cy="12" r="9" strokeWidth="2" /><circle cx="12" cy="12" r="5" strokeWidth="1" opacity="0.3" /><rect x="9.5" y="9.5" width="5" height="5" rx="1" strokeWidth="2" /></g>,
                Store: <path d="m2 7 4.41-4.41A2 2 0 0 1 7.83 2h8.34a2 2 0 0 1 1.42.59L22 7M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8M15 22v-4a2 2 0 0 0-1-1.73h-2v4" />,
                Backpack: <path d="M4 20V10a4 4 0 0 1 4-4h8a4 4 0 0 1 4-4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2Zm4-14V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />,
                Sword: <path d="M14.5 17.5 3 6V3h3l11.5 11.5M13 19l6 6M16 16l6 6" />,
                Shield: <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10Z" />,
                Crown: <path d="M2 4 5 12 12 6 19 12 22 4 12 2Z" />,
                ScrollText: <path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4M14 2v6h6M8 18h8M8 14h8" />,
                Coffee: <path d="M17 8h1a4 4 0 1 1 0 8h-1M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4Z" />,
                ChevronRight: <path d="m9 18 6-6-6-6" />,
                Zap: <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" />,
                Shirt: <path d="M20.38 3.46 16 2a4 4 0 0 1-8 0L3.62 3.46a2 2 0 0 0-1.62 1.96V10a2 2 0 0 0 2 2h2v8a2 2 0 0 0 2-2V5.42a2 2 0 0 0-1.62-1.96Z" />,
                Gem: <path d="M6 3h12l4 6-10 12L2 9z" />,
                Footprints: <path d="M4 16v-2.3a2 2 0 1 1 2-2.9 4.4 4.4 0 0 0-2 3.5v1.7ZM14 4v2.3a2 2 0 1 0 2 2.9 4.4 4.4 0 0 1-2-3.5V4ZM10 12v2.3a2 2 0 1 1 2-2.9 4.4 4.4 0 0 0-2 3.5v1.7Z" />,
                Trash: <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2M10 11v6M14 11v6" />,
                Settings: <g><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1-1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" /><circle cx="12" cy="12" r="3" /></g>,
                Hammer: <path d="m15 12-8.5 8.5c-.83.83-2.17.83-3 0 0 0 0 0 0 0a2.12 2.12 0 0 1 0-3L12 9M17.64 15 22 10.64M20.91 11.7l-1.25-1.25c-.6-.6-.93-1.4-.93-2.23V5a2 2 0 0 0-2-2h-3.23c-.82 0-1.62.33-2.22.93L10.03 5.18a2 2 0 0 0 0 2.82L15 13a2 2 0 0 0 2.82 0l1.1-1.1a2 2 0 0 0 0-2.82L15 5" />,
                History: <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8M3 3v5h5M12 7v5l4 2" />,
                LogOut: <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9" />,
                Save: <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2zM17 21v-8H7v8M7 3v5h8" />,
                HeartPulse: <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z M3.22 12H9.5l.5-1 2 4.5 2-7 1.5 3.5h5.27" />,
                Flame: <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z" />,
                Droplet: <path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5s-3 3.5-3 5.5a7 7 0 0 0 7 7z" />,
                Plus: <path d="M5 12h14M12 5v14" />,
                Minus: <path d="M5 12h14" />,
                Check: <polyline points="20 6 9 17 4 12" />,
                Play: <polygon points="5 3 19 12 5 21 5 3" />,
                PlayCircle: <g><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></g>,
                PauseCircle: <g><circle cx="12" cy="12" r="10"/><line x1="10" y1="15" x2="10" y2="9"/><line x1="14" y1="15" x2="14" y2="9"/></g>,
                FastForward: <g><polygon points="13 19 22 12 13 5 13 19" /><polygon points="2 19 11 12 2 5 2 19" /></g>,
                Target: <g><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></g>,
                Wind: <path d="M17.7 7.7A2.5 2.5 0 1 1 15.8 12H3 M9.9 19a2.5 2.5 0 1 0 1.9-4.3H3 M20 4a2 2 0 1 1-2 2" />,
                Milk: <g><path d="M8 2h8v4H8z"/><path d="M6 6h12l1 5v9a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-9l1-5z"/><path d="M10 12h4"/><path d="M10 16h4"/></g>,
                ChevronLeft: <path d="m15 18-6-6 6-6" />,
                User: <g><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></g>,
                ArrowUp: <path d="m18 15-6-6-6 6" />,
                ArrowDown: <path d="m6 9 6 6 6-6" />,
                Bot: <path d="M12 8V4H8 M12 8v4h4 M8 12h8v9a2 2 0 0 1-2 2H10a2 2 0 0 1-2-2v-9 M9 16h1 M14 16h1 M11 11h2" />,
                StopCircle: <g><circle cx="12" cy="12" r="10" /><rect x="9" y="9" width="6" height="6" /></g>,
                Gavel: <path d="m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z" />,
                FileUp: <g><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 12v6"/><path d="m15 15-3-3-3 3"/></g>,
                Trophy: <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6M18 9h1.5a2.5 2.5 0 0 0 0-5H18M4 22h16M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22M18 2H6v7a6 6 0 0 0 12 0V2Z" />,
                Skull: <g><path d="M12 12v6"/><path d="m16 20 2-2"/><path d="m6 20 2-2"/><circle cx="12" cy="12" r="10"/><path d="M12 8v.01"/><path d="M9 9v.01"/><path d="M15 9v.01"/></g>,
                Download: <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3" />,
                Sliders: <path d="M4 21v-7M4 10V3M12 21v-9M12 8V3M20 21v-5M20 12V3M1 14h6M9 8h6M17 16h6" />,
                Copy: <path d="M4 2h12a2 2 0 0 1 2 2v1h2a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2v-1H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm0 2v14h12V4H4zm14 4v12H8v1h10V8h-2z" />
            };

            return (
                <svg 
                    xmlns="http://www.w3.org/2000/svg" 
                    width={size} 
                    height={size} 
                    viewBox="0 0 24 24" 
                    fill="none" 
                    stroke="currentColor" 
                    strokeWidth="2" 
                    strokeLinecap="round" 
                    strokeLinejoin="round"
                    className={className}
                >
                    {icons[name] || <circle cx="12" cy="12" r="10" />}
                </svg>
            );
        };

        const HPDisplay = ({ current, max }) => (
            <div className="bg-black/40 px-1.5 py-0.5 rounded-lg mt-1 border border-white/20 shadow-md flex items-center justify-center gap-0.5 min-w-[50px]">
                <span className="text-[10px] font-black text-white leading-none">{current}</span>
                <span className="text-[10px] font-black text-white leading-none">/</span>
                <span className="text-[10px] font-black text-amber-400 leading-none">{max}</span>
            </div>
        );

        const StatusPanel = ({ player, playerDoubleStrikeTurns, playerBlessedTurns }) => {
            return (
                <div className="bg-slate-900 border-b border-slate-700 py-0.5 px-1 flex items-center shadow-inner shrink-0 relative z-20 gap-0.5 overflow-x-auto scrollbar-hide min-h-[30px] flex-nowrap whitespace-nowrap">
                    <span className="text-[12px] font-black text-amber-500 mr-0.5 shrink-0">ÊàëÊñπ</span>
                    {playerDoubleStrikeTurns > 0 && <span className="text-[11px] bg-blue-500 text-white px-1 py-0.5 rounded font-black animate-pulse whitespace-nowrap shadow-sm border border-blue-400 mr-0.5">‚öîÔ∏è x2</span>}
                    {playerBlessedTurns > 0 && <span className="text-[11px] bg-purple-500 text-white px-1 py-0.5 rounded font-black animate-pulse whitespace-nowrap shadow-sm border border-purple-400 mr-0.5">üî• Á•ùÁ¶è ({playerBlessedTurns})</span>}
                    <div className="flex items-center gap-0.5">
                        <div className="flex items-center gap-0.5 bg-slate-900 px-1 py-0.5 rounded border border-slate-600 shadow-sm">
                            <span className="text-[11px] font-black text-slate-500">ÊîªÊìä</span>
                            <span className="text-[13px] font-black text-orange-500 leading-none">{player.atk}</span>
                        </div>
                        <div className="flex items-center gap-0.5 bg-slate-900 px-1 py-0.5 rounded border border-slate-600 shadow-sm">
                            <span className="text-[11px] font-black text-slate-500">Èò≤Á¶¶</span>
                            <span className="text-[13px] font-black text-blue-500 leading-none">{player.def}</span>
                        </div>
                        <div className="flex items-center gap-0.5 bg-slate-900 px-1 py-0.5 rounded border border-slate-600 shadow-sm">
                            <span className="text-[11px] font-black text-slate-500">ÁîüÂëΩ</span>
                            <span className="text-[13px] font-black text-red-500 leading-none">{player.maxHp}</span>
                        </div>
                        <div className="flex items-center gap-0.5 bg-slate-900 px-1 py-0.5 rounded border border-slate-600 shadow-sm">
                            <span className="text-[11px] font-black text-slate-500">Êö¥Êìä</span>
                            <span className="text-[13px] font-black text-purple-400 leading-none">{(player.crit*100).toFixed(0)}%</span>
                        </div>
                        <div className="flex items-center gap-0.5 bg-slate-900 px-1 py-0.5 rounded border border-slate-600 shadow-sm">
                            <span className="text-[11px] font-black text-slate-500">ÈñÉÈÅø</span>
                            <span className="text-[13px] font-black text-teal-400 leading-none">{(player.evade*100).toFixed(0)}%</span>
                        </div>
                    </div>
                </div>
            );
        };

        const GameMenu = ({ hasSave, onLoad, onReset, onDeleteSave, onBackupRestore }) => {
            return (
                <div className="flex flex-col h-full bg-slate-700 relative overflow-hidden">
                    <div className="absolute top-0 left-0 w-full h-full bg-[url('https://www.transparenttextures.com/patterns/cubes.png')] opacity-10 pointer-events-none"></div>
                    
                    <div className="flex-1 flex flex-col items-center justify-center p-6 z-10 relative">
                        <div className="flex flex-col items-center mb-8">
                            <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/25.png" className="w-32 h-32 mb-2 floating-wrapper object-contain drop-shadow-xl" alt="Pikachu" />
                            <h1 className="text-4xl font-black text-slate-100 mb-1 text-center tracking-tighter leading-none">PIKACHU<br/><span className="text-orange-500">ADVENTURE</span></h1>
                            <div className="text-xs font-bold text-slate-300 uppercase tracking-[0.3em] bg-slate-800/50 px-3 py-1 rounded-full border border-slate-600">OneGame Edition</div>
                        </div>
                        
                        <div className="w-full max-w-[280px] flex flex-col gap-3">
                            <div className="flex gap-3 w-full">
                                {hasSave && (
                                    <div className="flex-1 relative group">
                                        <button onClick={onLoad} className="w-full btn-poke-blue font-black text-lg py-3 rounded-2xl habby-shadow active:scale-95 transition-all flex flex-col items-center justify-center gap-0.5 border-b-4 border-blue-700 active:border-b-0 active:translate-y-1">
                                            <Icon name="Save" size={24} /> Êé•Á∫å
                                        </button>
                                        <button onClick={onDeleteSave} className="absolute -top-2 -right-2 bg-rose-500 text-white w-6 h-6 flex items-center justify-center rounded-full shadow-md hover:bg-rose-600 transition-colors z-20 border border-slate-600">
                                            <Icon name="Trash" size={12} />
                                        </button>
                                    </div>
                                )}
                                <button onClick={onReset} className={`flex-1 bg-gradient-to-r from-red-500 to-red-600 text-white font-black text-lg py-3 rounded-2xl habby-btn-shadow active:scale-95 transition-all flex flex-col items-center justify-center gap-0.5 border-2 border-red-700 ${!hasSave ? 'w-full' : ''}`}>
                                    <Icon name="Sword" size={24} /> {hasSave ? 'ÈáçÁΩÆ' : 'ÈñãÂßãÂÜíÈö™'}
                                </button>
                            </div>
                            
                            <button onClick={onBackupRestore} className="w-full bg-slate-800 text-slate-300 font-black py-3 rounded-2xl habby-shadow active:scale-95 transition-all flex items-center justify-center gap-2 border-2 border-slate-600 hover:bg-slate-700 hover:text-white hover:border-slate-500">
                                <Icon name="FileUp" size={20} /> 
                                <span>Â≠òÊ™îÁÆ°ÁêÜ (Import/Export)</span>
                            </button>
                        </div>
                    </div>
                    
                    <div className="h-[200px] shrink-0 z-10 bg-slate-800 border-t-2 border-slate-600 flex flex-col shadow-[0_-10px_40px_rgba(0,0,0,0.3)]">
                        <div className="flex justify-between items-center px-6 py-3 bg-slate-900/50 border-b border-slate-700/50">
                            <div className="text-xs font-black text-slate-400 uppercase tracking-wider flex items-center gap-2">
                                <Icon name="ScrollText" size={14} /> Update Log
                            </div>
                            <div className="text-[10px] font-bold bg-slate-800 text-slate-300 px-2 py-0.5 rounded-full border border-slate-600">{VERSION}</div>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-3 scrollbar-hide">
                            {CHANGE_LOGS.slice(0, 3).map((log, i) => (
                                <div key={i} className={`${i === 0 ? 'bg-slate-700/30 -mx-2 px-3 py-2 rounded-lg border border-slate-600/30' : ''}`}>
                                    <div className={`text-[11px] font-black ${i === 0 ? 'text-green-400' : 'text-slate-400'} mb-1 flex justify-between items-center`}>
                                        {log.ver}
                                        {i === 0 && <span className="text-[9px] bg-green-500/20 text-green-300 px-1.5 rounded uppercase font-bold">New</span>}
                                    </div>
                                    <ul className="text-[10px] text-slate-400 font-bold space-y-1 pl-1">
                                        {log.changes.map((c, ci) => <li key={ci} className="leading-snug">‚Ä¢ {c}</li>)}
                                    </ul>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const Header = ({ player, isAutoAttack, autoSave, setAutoSave, setView, showModal, saveGame, setNewItems }) => {
            const [showSettingsMenu, setShowSettingsMenu] = useState(false);
            const settingsMenuRef = useRef(null);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (showSettingsMenu && settingsMenuRef.current && !settingsMenuRef.current.contains(event.target)) {
                        setShowSettingsMenu(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, [showSettingsMenu]);

            return (
                <div className="bg-slate-900 px-3 pt-6 pb-3 border-b-4 border-slate-700 flex justify-between items-end z-30 shrink-0 relative shadow-lg min-h-[80px]">
                    <div className="flex items-center gap-2" onClick={() => showModal({ type: 'profile' })}>
                        <div className="w-10 h-10 bg-slate-800 rounded-xl flex items-center justify-center habby-shadow text-2xl border-2 border-slate-600 overflow-hidden cursor-pointer active:scale-95 transition-transform hover:border-slate-400">
                            <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/25.png" className="w-8 h-8 object-contain scale-x-[-1]" alt="Pikachu" />
                        </div>
                        
                        <div className="flex flex-col justify-center h-full pt-1">
                            <div className="text-sm font-black text-orange-400 leading-none mb-1 truncate max-w-[140px] tracking-wide filter drop-shadow-sm">{player.title}</div>
                            <div className="flex items-center gap-2">
                                    <div className="text-xs font-black text-slate-300 italic uppercase leading-none">Lv.{player.level}</div>
                                    <div className="w-20 h-1.5 bg-slate-800 rounded-full border border-slate-600 overflow-hidden shadow-inner"><div className="h-full bg-orange-500 transition-all duration-300" style={{width: `${(player.exp/player.maxExp)*100}%`}}></div></div>
                            </div>
                        </div>
                    </div>

                    <div className="flex items-center gap-2 relative">
                        <div className="flex items-center gap-1 bg-slate-800 px-2.5 py-1.5 rounded-full habby-shadow text-xs font-black border border-slate-600 text-slate-200 mr-1"><Icon name="Coins" size={14} className="text-amber-500" /> {formatGold(player.gold)}</div>
                        <button 
                            onClick={() => setView('shop')} 
                            disabled={isAutoAttack} 
                            className={`h-10 px-3 rounded-xl flex items-center justify-center habby-btn-shadow transition-all gap-1.5 ${isAutoAttack ? 'bg-slate-700 opacity-50 cursor-not-allowed border-2 border-slate-600' : 'btn-poke-yellow active:scale-90'}`}
                        >
                            <Icon name="Store" size={18} className="text-white" /><span className="text-sm font-black text-white leading-none mt-0.5">ÂïÜÂ∫ó</span>
                        </button>
                        <div className="relative" ref={settingsMenuRef}>
                            <button 
                                onClick={() => setShowSettingsMenu(!showSettingsMenu)} 
                                className="w-10 h-10 rounded-xl flex items-center justify-center habby-btn-shadow active:scale-90 transition-all btn-poke-blue"
                            >
                                <Icon name="Settings" size={20} />
                            </button>
                            {showSettingsMenu && (
                                <div className="absolute top-full right-0 mt-3 w-max bg-slate-800 rounded-xl border-2 border-slate-600 shadow-2xl flex flex-col p-1.5 z-50 animate-in slide-in-from-top-2 duration-200">
                                    <div className="px-3 py-2 flex items-center justify-between gap-3 border-b border-slate-700">
                                        <span className="text-xs font-bold text-slate-300">Êà∞È¨•ÂâçËá™ÂãïÂ≠òÊ™î</span>
                                        <div className={`w-10 h-5 rounded-full relative cursor-pointer transition-colors ${autoSave ? 'bg-green-500' : 'bg-slate-600'}`} onClick={() => setAutoSave(!autoSave)}>
                                            <div className={`absolute top-0.5 w-4 h-4 bg-white rounded-full transition-transform shadow-sm ${autoSave ? 'left-[22px]' : 'left-0.5'}`}></div>
                                        </div>
                                    </div>
                                    <button onClick={() => { showModal({ type: 'log' }); setShowSettingsMenu(false); }} className="flex items-center gap-2 px-3 py-2.5 hover:bg-slate-700 rounded-lg text-xs font-bold text-slate-300 hover:text-white transition-colors whitespace-nowrap">
                                        <Icon name="History" size={14} /> ‰øÆÊîπÊó•Ë™å
                                    </button>
                                    <div className="h-px bg-slate-700 my-1"></div>
                                    <button onClick={() => saveGame()} className="flex items-center gap-2 px-3 py-3 hover:bg-slate-700 rounded-lg text-sm font-black text-teal-400 hover:bg-teal-900/30 transition-colors whitespace-nowrap">
                                        <Icon name="Save" size={18} /> ÂÑ≤Â≠òÈÄ≤Â∫¶
                                    </button>
                                    <button onClick={() => { 
                                        showModal({ 
                                            type: 'exit_confirm', 
                                            title: 'ÁµêÊùüÂÜíÈö™', 
                                            msg: 'Ë¶ÅÁµêÊùüÁõÆÂâçÁöÑÂÜíÈö™‰∏¶ÂõûÂà∞‰∏ªÈÅ∏ÂñÆÂóéÔºüÊú™ÂÑ≤Â≠òÁöÑÈÄ≤Â∫¶Â∞áÊúÉÈÅ∫Â§±„ÄÇ', 
                                            onConfirm: () => { setView('menu'); setNewItems([]); } 
                                        });
                                        setShowSettingsMenu(false);
                                    }} className="flex items-center gap-2 px-3 py-3 hover:bg-slate-700 rounded-lg text-sm font-black text-rose-400 hover:bg-rose-900/30 transition-colors whitespace-nowrap">
                                        <Icon name="LogOut" size={18} /> ÁµêÊùüÈÅäÊà≤
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const AdventureScene = ({ gameState, enemies, player, damages, needsResume, setNeedsResume, activeEnemyUid, playerAction }) => {
            return (
                <div className="h-48 adventure-bg relative flex items-center justify-center px-4 overflow-hidden shrink-0 shadow-inner border-b-2 border-slate-900/50">
                    <div className={`absolute top-0 left-0 w-[200%] h-full flex scroll-clouds ${gameState === 'walking' && !needsResume ? '' : 'paused'} z-0 pointer-events-none`}>
                        <div className="w-1/2 h-full relative">
                                <div className="cloud" style={{top: '15%', left: '10%'}}></div>
                                <div className="cloud" style={{top: '25%', left: '60%'}}></div>
                                <div className="cloud" style={{top: '10%', left: '85%', transform: 'scale(0.8)'}}></div>
                        </div>
                        <div className="w-1/2 h-full relative">
                                <div className="cloud" style={{top: '15%', left: '10%'}}></div>
                                <div className="cloud" style={{top: '25%', left: '60%'}}></div>
                                <div className="cloud" style={{top: '10%', left: '85%', transform: 'scale(0.8)'}}></div>
                        </div>
                    </div>

                    <div className={`absolute bottom-0 left-0 w-[200%] h-full flex items-end scroll-mountains ${gameState === 'walking' && !needsResume ? '' : 'paused'} z-1 pointer-events-none`}>
                            <div className="w-1/2 h-full relative">
                                <div className="mountain-container">
                                <div className="mountain" style={{left: '5%', transform: 'scale(0.8)', borderBottomColor: '#94a3b8'}}></div>
                                <div className="mountain" style={{left: '25%', transform: 'scale(1.3)', zIndex: 0, borderBottomColor: '#64748b'}}></div>
                                <div className="mountain" style={{left: '60%', transform: 'scale(1.1)', zIndex: 1, borderBottomColor: '#475569'}}></div>
                                <div className="mountain" style={{left: '85%', transform: 'scale(0.9)', zIndex: 0, borderBottomColor: '#94a3b8'}}></div>
                                </div>
                            </div>
                            <div className="w-1/2 h-full relative">
                                <div className="mountain-container">
                                <div className="mountain" style={{left: '5%', transform: 'scale(0.8)', borderBottomColor: '#94a3b8'}}></div>
                                <div className="mountain" style={{left: '25%', transform: 'scale(1.3)', zIndex: 0, borderBottomColor: '#64748b'}}></div>
                                <div className="mountain" style={{left: '60%', transform: 'scale(1.1)', zIndex: 1, borderBottomColor: '#475569'}}></div>
                                <div className="mountain" style={{left: '85%', transform: 'scale(0.9)', zIndex: 0, borderBottomColor: '#94a3b8'}}></div>
                                </div>
                            </div>
                    </div>
                    
                    <div className={`absolute bottom-0 left-0 w-[200%] h-1/2 flex scroll-ground ${gameState === 'walking' && !needsResume ? '' : 'paused'} z-2 pointer-events-none`}>
                        <div className="w-1/2 h-full relative">
                            <div className="stone" style={{left: '10%', top: '60%', width: '12px', height: '8px'}}></div>
                            <div className="stone" style={{left: '35%', top: '30%', width: '8px', height: '6px'}}></div>
                            <div className="stone" style={{left: '65%', top: '70%', width: '14px', height: '10px'}}></div>
                            <div className="stone" style={{left: '85%', top: '40%', width: '10px', height: '7px'}}></div>
                        </div>
                        <div className="w-1/2 h-full relative">
                            <div className="stone" style={{left: '10%', top: '60%', width: '12px', height: '8px'}}></div>
                            <div className="stone" style={{left: '35%', top: '30%', width: '8px', height: '6px'}}></div>
                            <div className="stone" style={{left: '65%', top: '70%', width: '14px', height: '10px'}}></div>
                            <div className="stone" style={{left: '85%', top: '40%', width: '10px', height: '7px'}}></div>
                        </div>
                    </div>

                    {needsResume && (
                        <div className="absolute inset-0 bg-black/60 z-40 flex items-center justify-center backdrop-blur-[2px]">
                            <button 
                                onClick={() => setNeedsResume(false)}
                                className="resume-btn-anim bg-amber-400 text-amber-900 font-black px-8 py-3 rounded-full border-4 border-white habby-btn-shadow flex items-center gap-2 transform active:scale-95 transition-all"
                            >
                                <Icon name="Play" size={24} /> ÁπºÁ∫åÂÜíÈö™
                            </button>
                        </div>
                    )}

                    {gameState === 'combat' && enemies.length > 0 ? (
                        <div className={`w-full flex justify-between items-end relative z-10 ${needsResume ? 'opacity-40' : ''}`}>
                            <div className="flex flex-col items-center w-1/3 relative z-10 translate-y-4">
                                <div className="relative">
                                    <div className={playerAction === 'attacking' ? 'animate-attack-right' : (damages.some(d => d.side === 'player' && !d.isMiss) ? 'animate-hit-shake' : 'floating-wrapper')}><img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/25.png" className="w-24 h-24 object-contain drop-shadow-lg scale-x-[-1]" alt="Pikachu" /></div>
                                    {damages.filter(d => d.side === 'player').map(d => <div key={d.id} className={`damage-number top-0 ${d.isMiss ? 'text-blue-400 text-sm' : 'text-red-500'}`}>{d.isMiss ? 'MISS' : `-${d.val}`}</div>)}
                                </div>
                                <div className="mt-2 w-20 h-2 bg-slate-800 rounded-full overflow-hidden border border-white shadow-sm"><div className="h-full bg-yellow-400 transition-all duration-300" style={{width: `${(player.hp/player.maxHp)*100}%`}}></div></div>
                                <HPDisplay current={player.hp} max={player.maxHp} />
                            </div>
                            <div className={`flex-1 flex items-end gap-1 relative h-full ${enemies.length === 1 ? 'justify-center pr-10' : 'justify-end pr-2 pl-2'}`}>
                                {enemies.map((enemy, idx) => {
                                    const isDead = enemy.hp <= 0;
                                    const baseClasses = "flex flex-col items-center relative transition-all duration-700 transform-gpu will-change-opacity translate-y-4";
                                    const activeClasses = idx === 0 ? 'z-20 scale-100 opacity-100' : 'z-10 scale-90 opacity-90';
                                    const deadClasses = 'z-0 scale-75 opacity-0 pointer-events-none grayscale'; 

                                    return (
                                    <div 
                                        key={enemy.uid} 
                                        className={`${baseClasses} ${isDead ? deadClasses : activeClasses}`}
                                    >
                                        {enemy.rank > 0 && (
                                            <div className={`absolute -top-11 left-1/2 -translate-x-1/2 text-[9px] font-black px-1.5 py-0.5 rounded-full whitespace-nowrap border mb-0.5 shadow-sm z-10 ${enemy.rank === 2 ? 'bg-red-600 text-white border-red-400' : 'bg-orange-500 text-white border-orange-400'}`}>
                                                {enemy.rank === 2 ? 'È¶ñÈ†ò' : 'ËèÅËã±'}
                                            </div>
                                        )}
                                        {enemy.hp > 0 && <div className="absolute -top-6 left-1/2 -translate-x-1/2 text-[10px] font-black text-white drop-shadow-md bg-black/40 px-2 rounded-full whitespace-nowrap border border-white/10">{enemy.name}</div>}
                                        <div className="relative">
                                                <div 
                                                    className={activeEnemyUid === enemy.uid ? 'animate-attack-left' : (damages.some(d => d.targetUid === enemy.uid) ? 'animate-hit-shake' : 'floating-wrapper')} 
                                                    style={activeEnemyUid === enemy.uid ? { '--attack-dist': `-${150 + idx * 100}px` } : {animationDelay: `${idx * 0.2}s`}}
                                                >
                                                <img src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${enemy.icon}.png`} className={`w-20 h-20 object-contain drop-shadow-lg ${enemy.rank === 2 ? 'scale-125 filter drop-shadow-[0_0_10px_rgba(239,68,68,0.5)]' : enemy.rank === 1 ? 'scale-110 filter drop-shadow-[0_0_5px_rgba(249,115,22,0.5)]' : ''} ${enemy.icon === '68' ? 'scale-x-[-1]' : ''}`} alt={enemy.name} />
                                                </div>
                                                {damages.filter(d => d.targetUid === enemy.uid).map(d => <div key={d.id} className={`damage-number top-0 ${d.isCrit ? 'text-yellow-400 text-xl' : d.isMiss ? 'text-blue-400 text-sm' : 'text-orange-500'}`}>{d.isMiss ? 'MISS' : (d.isCrit ? 'CRIT!' : '') + ' -' + d.val}</div>)}
                                                <div className="absolute -top-10 -right-4 flex flex-col gap-0.5 pointer-events-none z-50">
                                                {enemy.burnTurns > 0 && <span className="text-3xl animate-pulse drop-shadow-md">üî•</span>}
                                                {enemy.paralyzedTurns > 0 && <span className="text-3xl animate-pulse drop-shadow-md">‚ö°</span>}
                                                {enemy.weakenedTurns > 0 && <span className="text-3xl animate-pulse drop-shadow-md">üíÄ</span>}
                                                </div>
                                        </div>
                                        <div className="mt-1 w-12 h-1.5 bg-slate-800 rounded-full overflow-hidden border border-white shadow-sm"><div className="h-full bg-rose-600 transition-all duration-500" style={{width: `${(enemy.hp/enemy.maxHp)*100}%`}}></div></div>
                                        <HPDisplay current={enemy.hp} max={enemy.maxHp} />
                                    </div>
                                )})}
                            </div>
                        </div>
                    ) : (
                        <div className={`relative flex flex-col items-center z-10 ${needsResume ? 'opacity-40' : ''}`}>
                            <div className={gameState === 'walking' && !needsResume ? 'capy-walking-wrapper' : 'floating-wrapper'}><img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/25.png" className="w-32 h-32 object-contain drop-shadow-2xl scale-x-[-1]" alt="Pikachu" /></div>
                            <div className="w-32 h-6 bg-black/40 rounded-[50%] absolute -bottom-2 blur-md"></div>
                            <div className="mt-2 w-24 h-2 bg-slate-800 rounded-full overflow-hidden border border-white shadow-sm relative"><div className="h-full bg-yellow-400 transition-all duration-500" style={{width: `${(player.hp/player.maxHp)*100}%`}}></div></div>
                            <HPDisplay current={player.hp} max={player.maxHp} />
                        </div>
                    )}
                </div>
            );
        };

        const GameLogs = ({ logs, day, enemies }) => {
            const logContainerRef = useRef(null);

            useEffect(() => {
                if (logContainerRef.current) logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
            }, [logs]);

            return (
                <React.Fragment>
                    <div className="bg-slate-900 border-b border-slate-700 py-0.5 px-1 flex items-center shadow-md shrink-0 relative z-20 min-h-[36px] overflow-hidden whitespace-nowrap">
                        {enemies.length > 0 ? (
                            <div className="flex items-center flex-nowrap gap-0.5 w-full justify-center">
                                <span className="text-[12px] font-black text-rose-500 mr-0.5 shrink-0">ÊïµÊñπ</span>
                                {enemies.map((e, i) => {
                                    const isWeak = e.weakenedTurns > 0;
                                    return (
                                    <React.Fragment key={e.uid}>
                                        {i > 0 && e.hp > 0 && enemies.some((prevE, prevI) => prevI < i && prevE.hp > 0) && <div className="w-0.5 h-4 bg-yellow-400 mx-1 shrink-0 shadow-[0_0_4px_rgba(250,204,21,0.8)]"></div>}
                                        {e.hp > 0 && (
                                            <div className="flex items-center gap-0.5 shrink-0">
                                                <div className="flex items-center gap-0.5 bg-slate-900 px-1 py-0.5 rounded border border-slate-600 shadow-sm">
                                                    {e.rank === 2 && <span className="text-[11px] mr-1">üëë</span>}
                                                    <span className="text-[11px] font-black text-slate-500">ÊîªÊìä</span>
                                                    <span className={`text-[13px] font-black leading-none ${isWeak ? 'text-slate-500 line-through' : 'text-rose-400'}`}>{isWeak ? Math.floor(e.atk/2) : e.atk}</span>
                                                </div>
                                                <div className="flex items-center gap-0.5 bg-slate-900 px-1 py-0.5 rounded border border-slate-600 shadow-sm">
                                                    <span className="text-[11px] font-black text-slate-500">Èò≤Á¶¶</span>
                                                    <span className={`text-[13px] font-black leading-none ${isWeak ? 'text-slate-500 line-through' : 'text-blue-400'}`}>{isWeak ? Math.floor((e.def||0)/2) : (e.def || 0)}</span>
                                                </div>
                                            </div>
                                        )}
                                    </React.Fragment>
                                )})}
                            </div>
                        ) : (
                            <div className="w-full text-center text-sm font-bold text-slate-500 tracking-widest uppercase animate-pulse py-1">
                                - Ê≠£Âú®Êé¢Á¥¢Êú™Áü•ÁöÑÂçÄÂüü -
                            </div>
                        )}
                    </div>
                    <div className="flex-1 bg-slate-900 p-4 flex flex-col overflow-hidden shadow-inner">
                        <div className="flex justify-between items-center mb-2 text-slate-400 font-black text-sm uppercase italic tracking-widest border-b border-slate-800 pb-1">
                            <div className="flex items-center gap-2"><Icon name="ScrollText" size={16} className="text-amber-500" /> Adventure Logs</div>
                            <div className="text-amber-500">Day {day}</div>
                        </div>
                        <div ref={logContainerRef} className="flex-1 overflow-y-auto pr-1 space-y-1.5 scrollbar-hide relative">
                            {logs.map(log => (
                                <div key={log.id} className={`log-item text-[13px] leading-relaxed font-bold border-l-4 pl-2 ${
                                    log.type === 'day_change' ? 'log-day-change border-0 pl-0' :
                                    log.type === 'danger' ? 'text-rose-400 border-rose-500' : 
                                    log.type === 'success' ? 'text-emerald-400 border-emerald-500' : 
                                    log.type === 'special' ? 'text-purple-400 border-purple-500' : 
                                    log.type === 'attack' ? 'text-orange-300 border-orange-400' : 
                                    log.type === 'hit' ? 'text-red-300 border-red-400' : 
                                    'text-slate-400 border-slate-700'
                                }`}>{log.text}</div>
                            ))}
                        </div>
                    </div>
                </React.Fragment>
            );
        };

        const ControlPanel = ({ gameState, needsResume, combatStep, playerAction, turnLock, isAutoAttack, isAutoAdventure, setIsAutoAttack, setIsAutoAdventure, handlePlayerAttack, handleRun, handleNextStep, setView, setInventoryTab, playerBase, usePotion, setAutoPotionEnabled, autoPotionEnabled }) => {
            const [showPotionMenu, setShowPotionMenu] = useState(false);
            const potionMenuRef = useRef(null);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (showPotionMenu && potionMenuRef.current && !potionMenuRef.current.contains(event.target)) {
                        setShowPotionMenu(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, [showPotionMenu]);

            const isInventoryDisabled = isAutoAttack;
            const isAttackDisabled = combatStep !== 0 || playerAction !== 'idle' || turnLock || isAutoAttack;
            const isRunDisabled = combatStep !== 0 || turnLock || isAutoAttack;
            const isForwardDisabled = gameState !== 'idle' || needsResume || isAutoAdventure;
            const isAutoAdvDisabled = needsResume || (gameState !== 'idle' && gameState !== 'walking');

            return (
                <div className="p-4 bg-slate-800 border-t-2 border-slate-700 shrink-0">
                    <div className="flex flex-col gap-3">
                        <div className="flex gap-3">
                            <button 
                                onClick={() => { setView('inventory'); setInventoryTab('All'); }} 
                                disabled={isInventoryDisabled} 
                                className={`w-16 h-16 rounded-2xl flex flex-col items-center justify-center habby-btn-shadow transition-all shrink-0 ${isInventoryDisabled ? 'bg-slate-700 opacity-50 cursor-not-allowed border-2 border-slate-600' : 'btn-poke-blue active:scale-90'}`}
                            >
                                <Icon name="Backpack" size={28} className="text-white" /><span className="text-[11px] font-black text-white uppercase mt-0.5">ËÉåÂåÖ</span>
                            </button>
                            <div className="relative w-16 h-16 shrink-0" ref={potionMenuRef}>
                                {showPotionMenu && (
                                    <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-3 poke-panel p-2 rounded-2xl habby-shadow border-2 flex flex-col gap-2 popup-menu z-50 min-w-[150px] shadow-2xl">
                                            <div className="flex items-center gap-2 p-2 rounded-xl hover:bg-slate-700 w-full transition-colors relative group">
                                                <button onClick={() => usePotion('heal')} disabled={playerBase.potions <= 0} className="flex-1 flex items-center gap-3 disabled:opacity-50 text-left">
                                                    <div className="relative shrink-0">
                                                        <Icon name="Coffee" size={24} className="text-red-500" />
                                                        <div className="absolute -bottom-1 -right-1 bg-slate-900 text-white text-[10px] font-black w-4 h-4 rounded-full flex items-center justify-center border border-slate-600">{playerBase.potions}</div>
                                                    </div>
                                                    <span className="text-sm font-black text-slate-300">ÁîüÂëΩËó•Ê∞¥</span>
                                                </button>
                                                <div className="flex flex-col items-center gap-1 pl-2 border-l border-slate-600" onClick={(e) => e.stopPropagation()}>
                                                    <span className="text-[9px] font-bold text-slate-400 leading-none">Ëá™Âãï</span>
                                                    <div 
                                                        onClick={() => setAutoPotionEnabled(!autoPotionEnabled)}
                                                        className={`w-8 h-4 rounded-full relative cursor-pointer transition-colors ${autoPotionEnabled ? 'bg-green-500' : 'bg-slate-600'}`}
                                                    >
                                                        <div className={`absolute top-0.5 w-3 h-3 bg-white rounded-full transition-transform shadow-sm ${autoPotionEnabled ? 'left-[18px]' : 'left-0.5'}`}></div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <button onClick={() => usePotion('paralyze')} disabled={playerBase.paralyzePotions <= 0} className="flex items-center gap-3 p-2 rounded-xl hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed w-full text-left transition-colors">
                                                <div className="relative shrink-0">
                                                    <Icon name="Zap" size={24} className="text-yellow-500" />
                                                    <div className="absolute -bottom-1 -right-1 bg-slate-900 text-white text-[10px] font-black w-4 h-4 rounded-full flex items-center justify-center border border-slate-600">{playerBase.paralyzePotions}</div>
                                                </div>
                                                <span className="text-sm font-black text-slate-300">È∫ªÁó∫Ëó•Ê∞¥</span>
                                            </button>
                                            <button onClick={() => usePotion('double')} disabled={playerBase.doublePotions <= 0} className="flex items-center gap-3 p-2 rounded-xl hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed w-full text-left transition-colors">
                                                <div className="relative shrink-0">
                                                    <Icon name="Swords" size={24} className="text-blue-500" />
                                                    <div className="absolute -bottom-1 -right-1 bg-slate-900 text-white text-[10px] font-black w-4 h-4 rounded-full flex items-center justify-center border border-slate-600">{playerBase.doublePotions}</div>
                                                </div>
                                                <span className="text-sm font-black text-slate-300">ÈÄ£ÊìäËó•Ê∞¥</span>
                                            </button>
                                            <div className="absolute -bottom-1.5 left-1/2 -translate-x-1/2 w-3 h-3 bg-slate-800 border-b-2 border-r-2 border-slate-700 rotate-45"></div>
                                    </div>
                                )}
                                <button onClick={() => setShowPotionMenu(!showPotionMenu)} className={`w-16 h-16 rounded-2xl flex flex-col items-center justify-center habby-btn-shadow transition-all relative btn-poke-green active:scale-90`}>
                                    <Icon name="Coffee" size={28} className="text-white" />
                                    <span className="text-[11px] font-black text-white uppercase mt-0.5">Ëó•Ê∞¥</span>
                                    <div className="absolute -bottom-2 -right-2 bg-slate-900 text-white text-[10px] font-black px-1.5 py-0.5 rounded-full border border-slate-600 z-10 shadow-sm">{playerBase.potions + playerBase.paralyzePotions + playerBase.doublePotions}</div>
                                </button>
                            </div>
                            {gameState === 'combat' && !needsResume ? (
                                <div className="flex-1 flex gap-2 min-w-0">
                                    <button 
                                        onClick={handlePlayerAttack} 
                                        disabled={isAttackDisabled} 
                                        className={`flex-[2] rounded-2xl font-black text-sm habby-btn-shadow transition-all border-2 flex flex-col items-center justify-center gap-0.5 shadow-lg ${isAttackDisabled ? 'bg-slate-600 text-slate-300 border-slate-500 opacity-50 cursor-not-allowed' : 'bg-gradient-to-b from-red-500 to-red-600 text-white border-red-700 active:scale-95'}`}
                                    >
                                        <Icon name="Sword" size={20} /> 
                                        <span>ÊîªÊìä</span>
                                    </button>
                                    <button 
                                        onClick={() => setIsAutoAttack(!isAutoAttack)} 
                                        className={`flex-[2] rounded-2xl font-black text-xs habby-btn-shadow transition-all border-2 flex flex-col items-center justify-center gap-0.5 active:scale-95 ${isAutoAttack ? 'bg-amber-500 text-white border-amber-600' : 'bg-sky-600 text-white border-sky-500 hover:bg-sky-500'}`}
                                    >
                                        <Icon name={isAutoAttack ? "PauseCircle" : "PlayCircle"} size={20} /> 
                                        <span>{isAutoAttack ? 'ÂÅúÊ≠¢' : 'Ëá™ÂãïÊîªÊìä'}</span>
                                    </button>
                                    <button 
                                        onClick={handleRun} 
                                        disabled={isRunDisabled} 
                                        className={`flex-[1] rounded-2xl font-black text-xs habby-btn-shadow transition-all border-2 flex flex-col items-center justify-center gap-0.5 ${isRunDisabled ? 'bg-slate-600 text-slate-300 border-slate-500 opacity-50 cursor-not-allowed' : 'bg-indigo-500 text-white border-indigo-600 hover:bg-indigo-400 active:scale-95'}`}
                                    >
                                        <Icon name="Wind" size={20} /> 
                                        <span>ÈÄÉË∑ë</span>
                                    </button>
                                </div>
                            ) : (
                                <div className="flex-1 flex gap-2 min-w-0">
                                    <button 
                                        onClick={handleNextStep} 
                                        disabled={isForwardDisabled} 
                                        className={`flex-[2] h-16 rounded-2xl text-white font-black text-xl tracking-widest habby-btn-shadow transition-all ${isForwardDisabled ? 'bg-slate-600 opacity-50 cursor-not-allowed border-2 border-slate-500' : 'bg-gradient-to-b from-yellow-400 to-orange-500 border-2 border-orange-600 active:scale-95'}`}
                                    >
                                        {gameState === 'walking' ? 'ÂâçÈÄ≤‰∏≠...' : needsResume ? 'Êö´ÂÅú‰∏≠' : 'ÂâçÈÄ≤'}
                                    </button>
                                    <button 
                                        onClick={() => setIsAutoAdventure(!isAutoAdventure)} 
                                        disabled={isAutoAdvDisabled}
                                        className={`flex-[1.5] h-16 rounded-2xl font-black text-sm habby-btn-shadow transition-all border-2 flex flex-col items-center justify-center gap-0.5 ${isAutoAdvDisabled ? 'bg-slate-700 text-slate-300 border-slate-600 opacity-50 cursor-not-allowed' : (isAutoAdventure ? 'bg-amber-500 text-white border-amber-600 active:scale-95' : 'bg-sky-600 text-white border-sky-500 hover:bg-sky-500 active:scale-95')}`}
                                    >
                                        <Icon name={isAutoAdventure ? "StopCircle" : "FastForward"} size={20} />
                                        <span>{isAutoAdventure ? 'ÂÅúÊ≠¢' : 'Ëá™ÂãïÂâçÈÄ≤'}</span>
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const ItemStatsDisplay = ({ item, equippedItem, isEquippedContext }) => {
            const stats = getItemStats(item);
            const equippedStats = equippedItem ? getItemStats(equippedItem) : { atk: 0, def: 0, hp: 0, evade: 0 };
            const renderStat = (label, val, comparedVal) => {
                if (val <= 0) return null;
                let colorClass = "text-slate-400"; 
                if (isEquippedContext) {
                    colorClass = "text-orange-400"; 
                } else {
                    if (!equippedItem) {
                        colorClass = "text-green-400"; 
                    } else if (val > comparedVal) {
                        colorClass = "text-green-400"; 
                    } else if (val < comparedVal) {
                        colorClass = "text-rose-400"; 
                    }
                }
                return (
                    <div className={`text-[11px] font-black ${colorClass} whitespace-nowrap`}>
                        {label}+{val}
                    </div>
                );
            };
            return (
                <div className="flex flex-col items-center w-full mt-1">
                    <div className="flex flex-wrap gap-x-1.5 justify-center leading-none mb-0.5">
                        {renderStat("ATK", stats.atk, equippedStats.atk)}
                        {renderStat("DEF", stats.def, equippedStats.def)}
                        {renderStat("HP", stats.hp, equippedStats.hp)}
                    </div>
                    {item.effects && item.effects.length > 0 && (
                        <div className="flex flex-wrap gap-x-1 justify-center leading-none mt-0.5">
                            {item.effects.map((e, idx) => (
                                <span key={idx} className="text-[10px] font-black text-purple-300 whitespace-nowrap">
                                    [{e.name}]
                                </span>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const InventoryView = ({ inventory, equipped, player, upgradeTarget, fodderIds, newItems, inventoryTab, highlightedSlot, setUpgradeTarget, setFodderIds, setInventoryTab, setView, setNewItems, handleItemClick, handleQuickUpgrade, handleQuickSell, executeUpgrade, toggleFodder, showModal, playerBase, filteredInventory }) => {
            return (
                <div className="absolute inset-0 bg-slate-800 z-40 flex flex-col p-6 pt-12 animate-in slide-in-from-bottom duration-300">
                    <div className="flex justify-between items-center mb-6">
                        <h2 className="text-2xl font-black italic text-slate-100 flex items-center gap-2 tracking-tighter">
                            <Icon name={upgradeTarget ? "Hammer" : "Backpack"} size={28} className="text-orange-500" /> 
                            {upgradeTarget ? 'Ë£ùÂÇôÂº∑Âåñ' : 'Ë£ùÂÇôËàáËÉåÂåÖ'}
                        </h2>
                        
                        {upgradeTarget && (
                            <div className="flex items-center gap-1 bg-slate-900 px-3 py-1.5 rounded-full border border-slate-700 shadow-inner">
                                <Icon name="Coins" size={14} className="text-amber-500" />
                                <span className="text-sm font-black text-slate-200">{formatGold(player.gold)}</span>
                            </div>
                        )}

                        <button 
                            onClick={() => { 
                                if(upgradeTarget){ 
                                    const targetSlot = upgradeTarget.slot;
                                    setUpgradeTarget(null); 
                                    setFodderIds([]); 
                                    const slotTabMap = {
                                        'weapon': 'Weapon', 'head': 'Head', 'body': 'Body',
                                        'ring': 'Ring', 'trinket': 'Trinket', 'shoes': 'Shoes'
                                    };
                                    setInventoryTab(slotTabMap[targetSlot] || 'All');
                                } else { 
                                    setView('adventure'); 
                                    setNewItems([]); 
                                } 
                            }} 
                            className="w-10 h-10 rounded-full bg-slate-700 flex items-center justify-center font-black habby-shadow text-slate-300 hover:bg-rose-500 hover:text-white transition-colors border border-slate-600"
                        >
                            ‚úï
                        </button>
                    </div>
                    {upgradeTarget ? (
                        <div className="poke-panel rounded-2xl p-3 habby-shadow border-2 mb-2 shrink-0 animate-in slide-in-from-top duration-300">
                                <div className="flex items-center gap-3 mb-2">
                                <div className={`w-14 h-14 rounded-xl bg-slate-800 border-2 flex items-center justify-center relative shrink-0 ${upgradeTarget.rarity === 'Legendary' ? 'border-amber-400 bg-amber-900/30' : 'border-slate-600'}`}>
                                        <Icon name={upgradeTarget.icon} size={28} className={getRarityColor(upgradeTarget.rarity)} />
                                        <div className="absolute -top-1.5 -right-1.5 bg-orange-500 text-white text-[10px] font-black px-1.5 py-0.5 rounded-full shadow border border-slate-600">Lv.{upgradeTarget.level}</div>
                                </div>
                                <div className="flex-1 min-w-0">
                                    <div className="flex justify-between items-baseline">
                                        <div className={`font-black truncate flex items-center gap-1 text-sm ${getRarityColor(upgradeTarget.rarity)}`}>
                                            {upgradeTarget.name}
                                            <span className="text-[10px] font-bold bg-slate-800 text-slate-300 px-1.5 rounded uppercase border border-slate-600">{upgradeTarget.slot}</span>
                                        </div>
                                        {(() => {
                                                const totalFodderExp = inventory.filter(i => fodderIds.includes(i.uid)).reduce((acc, i) => acc + getFodderExp(i, upgradeTarget.slot), 0);
                                                let tempExp = upgradeTarget.exp + totalFodderExp;
                                                let tempLvl = upgradeTarget.level;
                                                while(tempExp >= getExpReq(tempLvl)) { tempExp -= getExpReq(tempLvl); tempLvl++; }
                                                return tempLvl > upgradeTarget.level ? <span className="text-xs font-black text-green-400 ml-1">‚Æï Lv.{tempLvl}</span> : null;
                                        })()}
                                    </div>
                                    <div className="text-xs font-bold text-slate-400 mt-1 leading-tight space-y-0.5">
                                        {upgradeTarget.effects && upgradeTarget.effects.length > 0 ? (
                                            upgradeTarget.effects.map((eff, i) => (
                                                <div key={i} className={eff.color}>
                                                    {eff.name}Ôºö{getEffectDesc(eff, upgradeTarget.level || 1)}
                                                </div>
                                            ))
                                        ) : <span className="opacity-50">ÁÑ°ÁâπÊÆäÂ±¨ÊÄß</span>}
                                    </div>
                                </div>
                            </div>
                            <div className="flex items-center gap-2 mb-2">
                                    <div className="flex-1 h-2.5 bg-slate-800 rounded-full overflow-hidden border border-slate-600 relative">
                                    <div className="h-full bg-orange-500 transition-all duration-300 absolute top-0 left-0 z-10" style={{width: `${(upgradeTarget.exp / getExpReq(upgradeTarget.level)) * 100}%`}}></div>
                                    <div className="h-full bg-green-500 transition-all duration-300 absolute top-0 left-0 z-0" 
                                        style={{width: `${Math.min(100, ((upgradeTarget.exp + inventory.filter(i => fodderIds.includes(i.uid)).reduce((acc, i) => acc + getFodderExp(i, upgradeTarget.slot), 0)) / getExpReq(upgradeTarget.level)) * 100)}%`}}>
                                    </div>
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={() => setFodderIds([])} disabled={fodderIds.length === 0} className="px-4 py-2 bg-slate-700 text-slate-300 font-black rounded-lg text-xs hover:bg-slate-600 transition-colors border border-slate-600">ÂèñÊ∂àÂÖ®ÈÉ®</button>
                                <button onClick={executeUpgrade} disabled={fodderIds.length===0} className={`flex-1 py-2 font-black rounded-lg text-xs flex items-center justify-center gap-1 transition-all border border-transparent ${fodderIds.length>0 ? 'btn-poke-yellow' : 'bg-slate-800 text-slate-500 cursor-not-allowed'}`}>
                                    <Icon name="Hammer" size={14} /> 
                                    {fodderIds.length > 0 ? `Á¢∫Ë™çÂº∑Âåñ (Ê∂àËÄó ${fodderIds.length * 80} G)` : 'ÈÅ∏ÊìáÁ•≠ÂìÅ'}
                                </button>
                            </div>
                        </div>
                    ) : (
                        <div className="grid grid-cols-3 gap-2 mb-4 shrink-0">
                            {['weapon', 'head', 'body', 'ring', 'trinket', 'shoes'].map(slot => (
                                <button key={slot} onClick={() => handleItemClick(equipped[slot] || null, 'equipped')} disabled={!equipped[slot] && !!upgradeTarget} 
                                    className={`min-h-[110px] rounded-2xl border-2 flex flex-col items-center justify-center habby-shadow relative overflow-hidden transition-all group p-1 ${equipped[slot] ? (equipped[slot]?.rarity === 'Legendary' ? 'bg-amber-950 border-amber-500' : 'bg-slate-800 border-amber-600') : 'poke-panel'} ${highlightedSlot === slot ? 'equip-highlight-red' : (inventoryTab !== 'All' && inventoryTab.toLowerCase() === slot ? 'active-slot-anim border-green-500 z-10' : '')}`}>
                                    {equipped[slot] ? (
                                        <React.Fragment>
                                            <div onClick={(e) => handleQuickUpgrade(e, equipped[slot])} className="absolute top-1 left-1 bg-orange-500 text-white w-7 h-7 rounded-lg flex items-center justify-center shadow-md z-20"><Icon name="Hammer" size={16} /></div>
                                            <Icon name={equipped[slot]?.icon || ""} size={24} className={`${getRarityColor(equipped[slot]?.rarity || 'Common')} mb-0.5`} />
                                            <div className={`text-[13px] font-black uppercase leading-none w-full truncate text-center ${getRarityColor(equipped[slot]?.rarity || 'Common')} mb-1`}>Lv.{equipped[slot]?.level||1} {equipped[slot]?.name}</div>
                                            <ItemStatsDisplay 
                                                item={equipped[slot]} 
                                                equippedItem={equipped[slot]} 
                                                isEquippedContext={true} 
                                            />
                                        </React.Fragment>
                                    ) : (
                                        <React.Fragment>
                                            <Icon name={slot === 'weapon' ? 'Sword' : slot === 'head' ? 'Crown' : slot === 'body' ? 'Shirt' : slot === 'ring' ? 'Gem' : slot === 'trinket' ? 'Zap' : 'Footprints'} size={24} className="text-slate-600" />
                                            <div className="text-[10px] font-black uppercase text-slate-500 mt-1">{slot}</div>
                                        </React.Fragment>
                                    )}
                                </button>
                            ))}
                        </div>
                    )}
                    <div className="flex gap-1 mb-2 shrink-0 overflow-x-auto pb-1 scrollbar-hide">
                        {['All', 'Weapon', 'Head', 'Body', 'Ring', 'Trinket', 'Shoes'].map(tab => (
                            <button 
                                key={tab} 
                                onClick={() => setInventoryTab(tab)} 
                                className={`px-3 py-1.5 rounded-full text-[10px] font-black transition-all ${inventoryTab === tab ? 'bg-orange-500 text-white habby-shadow' : 'bg-slate-700 text-slate-400 border border-slate-600'}`}
                            >
                                {tab === 'All' ? 'ÂÖ®ÈÉ®' : tab === 'Weapon' ? 'Ê≠¶Âô®' : tab === 'Head' ? 'È†≠ÈÉ®' : tab === 'Body' ? 'Ë∫´È´î' : tab === 'Shoes' ? 'ÈûãÂ≠ê' : tab === 'Ring' ? 'ÊàíÊåá' : 'Ë≠∑Á¨¶'}
                            </button>
                        ))}
                    </div>
                    <div className="flex-1 overflow-y-auto mb-2 pr-1 scrollbar-hide">
                        <div className="grid grid-cols-3 gap-2">
                            {filteredInventory.map(item => {
                                const isSelected = fodderIds.includes(item.uid);
                                const isNew = newItems.includes(item.uid);
                                return (
                                <div key={item.uid} onClick={() => handleItemClick(item, 'inventory')} className={`min-h-[110px] rounded-2xl border-2 flex flex-col items-center justify-center habby-shadow relative overflow-hidden transition-all poke-panel cursor-pointer group p-1 ${isSelected ? 'border-orange-500 ring-2 ring-orange-900 scale-95' : (item.rarity === 'Legendary' ? 'border-amber-400 bg-amber-950/30' : 'border-slate-600 bg-slate-800/50')} ${isNew ? 'new-item-anim border-red-500 z-20' : ''}`}>
                                    {!upgradeTarget && (
                                        <React.Fragment>
                                            <div onClick={(e) => handleQuickUpgrade(e, item)} className="absolute top-1 left-1 bg-orange-500 text-white w-7 h-7 rounded-lg flex items-center justify-center shadow-md z-20"><Icon name="Hammer" size={16} /></div>
                                            <div onClick={(e) => handleQuickSell(e, item)} className="absolute top-1 right-1 bg-rose-500 text-white w-7 h-7 rounded-lg flex items-center justify-center shadow-md z-20"><Icon name="Trash" size={16} /></div>
                                        </React.Fragment>
                                    )}
                                    {isNew && (
                                        <div className="absolute top-0 left-1/2 -translate-x-1/2 bg-red-600 text-white text-[8px] font-black px-2 py-0.5 rounded-b-md shadow-md z-30 animate-pulse border-b border-x border-red-800 leading-none tracking-wider pointer-events-none">
                                            NEW
                                        </div>
                                    )}
                                    {isSelected && <div className="absolute inset-0 bg-slate-900/90 z-10 flex items-center justify-center"><Icon name="Check" className="text-green-500" size={24} /></div>}
                                    <Icon name={item.icon} size={24} className={`${getRarityColor(item.rarity)} mb-0.5`} />
                                    <div className={`text-[13px] font-black leading-none text-center px-0.5 truncate w-full ${getRarityColor(item.rarity)} mb-1`}>Lv.{item.level||1} {item.name}</div>
                                    <ItemStatsDisplay 
                                        item={item} 
                                        equippedItem={equipped[item.slot]} 
                                        isEquippedContext={false} 
                                    />
                                </div>
                            )})}
                        </div>
                    </div>
                    {!upgradeTarget && (
                        <div className="poke-panel px-3 py-4 rounded-[1.5rem] shadow-inner border-2 shrink-0 flex items-center gap-2">
                            <button onClick={() => showModal({ type: 'stat_allocation', tempAllocated: { ...playerBase.allocated }, tempPoints: playerBase.statPoints })} className="w-12 h-12 bg-amber-500 rounded-xl flex items-center justify-center habby-btn-shadow border border-amber-600 active:scale-95 transition-all text-white shrink-0 group">
                                <Icon name="Sliders" size={24} />
                            </button>
                            <div className="flex-1 grid grid-cols-5 gap-1 text-center min-w-0">
                                <div><div className="text-[12px] font-black text-slate-500 uppercase whitespace-nowrap">Á∏ΩÊîªÊìä</div><div className="text-xl font-black text-orange-500 tracking-tighter leading-none whitespace-nowrap">{player.atk}</div></div>
                                <div><div className="text-[12px] font-black text-slate-500 uppercase whitespace-nowrap">Á∏ΩÈò≤Á¶¶</div><div className="text-xl font-black text-blue-500 tracking-tighter leading-none whitespace-nowrap">{player.def}</div></div>
                                <div><div className="text-[12px] font-black text-slate-500 uppercase whitespace-nowrap">Á∏ΩÁîüÂëΩ</div><div className="text-xl font-black text-red-500 tracking-tighter leading-none whitespace-nowrap">{player.maxHp}</div></div>
                                <div><div className="text-[12px] font-black text-slate-500 uppercase whitespace-nowrap">Êö¥ÊìäÁéá</div><div className="text-xl font-black text-purple-400 tracking-tighter leading-none whitespace-nowrap">{Math.round(player.crit*100)}%</div></div>
                                <div><div className="text-[12px] font-black text-slate-500 uppercase whitespace-nowrap">ÈñÉÈÅøÁéá</div><div className="text-xl font-black text-teal-400 tracking-tighter leading-none whitespace-nowrap">{Math.round(player.evade*100)}%</div></div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const ShopView = ({ player, setView, showModal }) => {
            return (
                <div className="absolute inset-0 bg-slate-800 z-40 flex flex-col p-6 pt-12 animate-in slide-in-from-right duration-300">
                    <div className="flex justify-between items-center mb-6">
                        <h2 className="text-2xl font-black italic text-slate-100 flex items-center gap-2"><Icon name="Store" size={28} className="text-orange-500" /> ÁöÆÂç°‰∏òÂïÜÂ∫ó</h2>
                        <div className="flex items-center gap-1 bg-slate-900 px-3 py-1.5 rounded-full border border-slate-700 shadow-inner"><Icon name="Coins" size={14} className="text-amber-500" /><span className="text-sm font-black text-slate-200">{formatGold(player.gold)}</span></div>
                        <button onClick={() => setView('adventure')} className="w-10 h-10 rounded-full bg-slate-700 flex items-center justify-center font-black habby-shadow text-slate-400 ml-2 hover:bg-rose-500 hover:text-white transition-colors border border-slate-600">‚úï</button>
                    </div>
                    <div className="flex-1 overflow-y-auto pr-1 scrollbar-hide pb-6">
                        <div className="grid grid-cols-2 gap-2">
                            {SHOP_ITEMS.map(item => {
                                const canAfford = player.gold >= item.price;
                                return (
                                    <div key={item.id} className="poke-panel rounded-2xl p-2 border-2 flex flex-col items-center gap-1.5 habby-shadow text-center">
                                        <div className="w-10 h-10 bg-slate-800 rounded-xl flex items-center justify-center shadow-inner border border-slate-600 shrink-0"><Icon name={item.icon} size={20} className="text-amber-500" /></div>
                                        <div className="flex-1 w-full flex flex-col justify-center">
                                            <div className="font-black text-slate-100 text-sm leading-tight truncate">{item.name}</div>
                                            <div className="text-[11px] font-bold text-slate-400 mt-0.5 line-clamp-2">{item.desc}</div>
                                        </div>
                                        <button onClick={() => canAfford ? showModal({ type: 'buy', item, qty: 1 }) : null} disabled={!canAfford} className={`w-full px-2 py-1.5 rounded-lg font-black flex items-center justify-center gap-1 transition-all h-8 ${canAfford ? 'bg-orange-500 text-white active:scale-95' : 'bg-slate-800 text-slate-500 cursor-not-allowed'}`}>
                                            <Icon name="Coins" size={14} /> <span>{item.price}</span>
                                        </button>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const ModalManager = ({
            modal, player, closeModal, setModal, confirmPurchase, handleStatChange, resetStats, confirmStats,
            setPlayerBase, handleCaveDecision, downloadSaveFile, handleFileImport, handleLevelUpChoice, levelUpOptions,
            handleCopySaveToClipboard, handleImportData
        }) => {
            const [expandedCategory, setExpandedCategory] = useState('combat');
            const [importCode, setImportCode] = useState('');

            if (modal.type === 'levelup' && levelUpOptions && handleLevelUpChoice) {
                return (
                    <div className="absolute inset-0 bg-black/80 z-[60] flex items-center justify-center p-8 backdrop-blur-md">
                        <div className="bg-slate-800 w-full rounded-[3rem] p-6 border-8 border-orange-500 flex flex-col items-center shadow-2xl relative">
                            <h3 className="text-2xl font-black text-slate-100 italic mt-6 uppercase">Á≠âÁ¥öÊèêÂçáÔºÅ</h3>
                            <div className="w-full space-y-3 mt-4">
                                {levelUpOptions.map((opt, i) => (
                                    <button key={i} onClick={() => handleLevelUpChoice(opt)} className="w-full bg-slate-700 p-4 rounded-2xl border-2 border-slate-600 text-left hover:border-orange-500 transition-all flex items-center gap-3">
                                        <Icon name={opt.icon} size={24} className="text-orange-500" />
                                        <div>
                                            <div className="font-black text-slate-200 leading-none">{opt.label}</div>
                                            <div className="text-xs font-bold text-slate-400 leading-none mt-1">{opt.desc}</div>
                                        </div>
                                    </button>
                                ))}
                            </div>
                            <div className="mt-4 text-sm text-slate-400 font-bold">Áç≤Âæó {POINTS_PER_LEVEL} ÈªûÂ±¨ÊÄßÈªûÔºåË´ãËá≥ËÉåÂåÖÂàÜÈÖç</div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="absolute inset-0 bg-black/80 z-50 flex items-center justify-center p-8 backdrop-blur-sm animate-in fade-in duration-200">
                    <div className="bg-slate-800 w-full rounded-[2.5rem] p-6 border-4 border-slate-600 flex flex-col items-center shadow-2xl relative">
                        {modal.type === 'buy' ? (
                            <React.Fragment>
                                <div className="flex items-center gap-1.5 bg-slate-900 px-4 py-1.5 rounded-full border border-slate-700 shadow-inner mb-4">
                                    <Icon name="Coins" size={16} className="text-amber-500" />
                                    <span className="text-sm font-black text-slate-200">{formatGold(player.gold)}</span>
                                </div>
                                <div className="w-20 h-20 bg-slate-900 rounded-3xl flex items-center justify-center text-amber-500 mb-4 border border-slate-700 shadow-inner"><Icon name={modal.item.icon} size={48} /></div>
                                <h3 className="text-xl font-black text-slate-100 mb-2">{modal.item.name}</h3>
                                <div className="w-full bg-slate-900 rounded-2xl p-4 flex items-center justify-between mb-8 border border-slate-700">
                                    <button onClick={() => setModal({...modal, qty: Math.max(1, modal.qty-1)})} className="w-10 h-10 bg-slate-800 rounded-xl flex items-center justify-center text-slate-400"><Icon name="Minus" size={16} /></button>
                                    <div className="flex flex-col items-center"><span className="text-2xl font-black text-slate-100">{modal.qty}</span></div>
                                    <button onClick={() => setModal({...modal, qty: modal.qty+1})} className="w-10 h-10 bg-slate-800 rounded-xl flex items-center justify-center text-slate-400"><Icon name="Plus" size={16} /></button>
                                </div>
                                <div className="w-full flex gap-3">
                                    <button onClick={() => closeModal()} className="flex-1 bg-slate-700 text-slate-300 font-black py-4 rounded-2xl border border-slate-600">ÂèñÊ∂à</button>
                                    <button onClick={() => (player.gold >= modal.item.price * modal.qty) ? confirmPurchase() : null} disabled={player.gold < modal.item.price * modal.qty} className={`flex-1 font-black py-4 rounded-2xl ${(player.gold >= modal.item.price * modal.qty) ? 'btn-poke-yellow' : 'bg-slate-800 text-slate-500'}`}>Á¢∫Ë™çË≥ºË≤∑ ({modal.item.price * modal.qty} G)</button>
                                </div>
                            </React.Fragment>
                        ) : modal.type === 'stat_allocation' ? (
                            (() => {
                                const diffAtk = modal.tempAllocated.atk - player.allocated.atk;
                                const diffDef = modal.tempAllocated.def - player.allocated.def;
                                const diffHp = (modal.tempAllocated.hp - player.allocated.hp) * 10;
                                const projAtk = (player.atk || 0) + diffAtk;
                                const projDef = (player.def || 0) + diffDef;
                                const projHp = player.maxHp + diffHp;
                                return (
                                    <div className="w-full">
                                        <div className="grid grid-cols-3 gap-2 mb-4 w-full">
                                            <div className="bg-slate-900 p-2 rounded-xl border border-slate-700 flex flex-col items-center justify-center shadow-inner min-h-[70px]">
                                                <span className="text-sm font-black text-slate-400 mb-0.5">ÊîªÊìäÂäõ</span>
                                                <span className="text-2xl font-black text-orange-500 leading-none">{projAtk}</span>
                                            </div>
                                            <div className="bg-slate-900 p-2 rounded-xl border border-slate-700 flex flex-col items-center justify-center shadow-inner min-h-[70px]">
                                                <span className="text-sm font-black text-slate-400 mb-0.5">Èò≤Á¶¶Âäõ</span>
                                                <span className="text-2xl font-black text-blue-500 leading-none">{projDef}</span>
                                            </div>
                                            <div className="bg-slate-900 p-2 rounded-xl border border-slate-700 flex flex-col items-center justify-center shadow-inner min-h-[70px]">
                                                <span className="text-sm font-black text-slate-400 mb-0.5">ÁîüÂëΩÂÄº</span>
                                                <span className="text-2xl font-black text-red-500 leading-none">{projHp}</span>
                                            </div>
                                        </div>
                                        <h3 className="text-2xl font-black text-slate-100 italic mb-4">Â±¨ÊÄßÈÖçÈªû (Ââ©È§ò: {modal.tempPoints})</h3>
                                        <div className="space-y-4 mb-8">
                                            {['atk', 'def', 'hp'].map(statKey => (
                                                <div key={statKey} className="bg-slate-700 p-2 rounded-2xl flex items-center justify-between border border-slate-600">
                                                    <div className="font-black text-slate-200 pl-2 text-lg">{statKey === 'atk' ? 'ÊîªÊìäÂäõ' : statKey === 'def' ? 'Èò≤Á¶¶Âäõ' : 'ÁîüÂëΩÂÄº'} ({modal.tempAllocated[statKey]})</div>
                                                    <div className="flex items-center gap-3">
                                                        <button onClick={() => handleStatChange(statKey, -1)} disabled={modal.tempAllocated[statKey] <= 0} className="w-10 h-10 rounded-lg bg-slate-800 text-slate-300 border border-slate-600 text-xl font-bold flex items-center justify-center">-</button>
                                                        <button onClick={() => handleStatChange(statKey, 1)} disabled={modal.tempPoints <= 0} className="w-10 h-10 rounded-lg bg-amber-500 text-white border border-amber-600 text-xl font-bold flex items-center justify-center">+</button>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                        <div className="flex gap-3">
                                            <button onClick={resetStats} className="flex-1 bg-rose-600 text-white font-black py-4 rounded-2xl border border-rose-500">ÈáçÁΩÆ</button>
                                            <button onClick={confirmStats} className="flex-[2] bg-teal-600 text-white font-black py-4 rounded-2xl border border-teal-500">Á¢∫Ë™çÂàÜÈÖç</button>
                                        </div>
                                    </div>
                                );
                            })()
                        ) : modal.type === 'profile' ? (
                            <div className="w-full flex flex-col h-[500px]">
                                <div className="flex justify-between items-center mb-4">
                                    <h3 className="text-2xl font-black text-slate-100 italic">ÂÜíÈö™ÂÆ∂Ê™îÊ°à</h3>
                                    <button onClick={() => closeModal()} className="text-slate-400 font-bold text-xl">‚úï</button>
                                </div>
                                <div className="flex-1 overflow-y-auto scrollbar-hide space-y-4">
                                    {Object.keys(ACHIEVEMENT_CATEGORIES).map(catKey => (
                                        <div key={catKey} className="bg-slate-800 rounded-2xl overflow-hidden border border-slate-600">
                                            <button onClick={() => setExpandedCategory(expandedCategory === catKey ? null : catKey)} className="w-full flex items-center justify-between p-3 bg-slate-700">
                                                <span className="font-black text-slate-200">{ACHIEVEMENT_CATEGORIES[catKey]}</span>
                                                <Icon name={expandedCategory === catKey ? "ArrowUp" : "ArrowDown"} size={16} />
                                            </button>
                                            {expandedCategory === catKey && (
                                                <div className="p-3 space-y-2 bg-slate-800/50">
                                                    {ACHIEVEMENTS.filter(a => a.category === catKey).map(ach => {
                                                        const isUnlocked = player.unlockedTitles.includes(ach.title);
                                                        const isEquipped = player.title === ach.title;
                                                        return (
                                                            <div key={ach.id} className={`p-3 rounded-xl border-2 flex items-center gap-3 ${isUnlocked ? 'bg-slate-700 border-slate-600' : 'bg-slate-900/50 border-slate-700 opacity-60'}`}>
                                                                <div className="flex-1 min-w-0">
                                                                    <div className="flex flex-col gap-0.5">
                                                                        <div className="font-black text-slate-100 text-lg truncate leading-tight">{ach.title}</div>
                                                                        <div className="text-sm font-bold text-amber-400 leading-tight">{ach.buffDesc}</div>
                                                                    </div>
                                                                    <div className="text-xs font-bold text-slate-400 truncate mt-1">{ach.desc}</div>
                                                                </div>
                                                                {isUnlocked ? (
                                                                    <button 
                                                                        onClick={() => setPlayerBase(p => ({ ...p, title: isEquipped ? 'ËèúÈ≥•ÂÜíÈö™ÂÆ∂' : ach.title }))} 
                                                                        className={`px-3 py-1.5 rounded-lg font-black text-[10px] min-w-[60px] transition-colors border-2 ${
                                                                            isEquipped 
                                                                                ? 'bg-rose-500 text-white border-rose-600 hover:bg-rose-600' 
                                                                                : 'bg-emerald-500 text-white border-emerald-600 hover:bg-emerald-600'
                                                                        }`}
                                                                    >
                                                                        {isEquipped ? 'Âç∏‰∏ã' : 'Ë£ùÂÇô'}
                                                                    </button>
                                                                ) : (
                                                                    <div className="px-3 py-1.5 rounded-lg font-black text-[10px] min-w-[60px] text-center bg-slate-800 text-slate-500 border-2 border-slate-600">
                                                                        Êú™Ëß£Èéñ
                                                                    </div>
                                                                )}
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ) : modal.type === 'confirm' || modal.type === 'gameover' || modal.type === 'exit_confirm' ? (
                            <React.Fragment>
                                <h3 className="text-xl font-black text-slate-100 mb-2">{modal.title}</h3>
                                <p className="text-sm text-slate-300 text-center mb-8 px-2 font-bold">{modal.msg}</p>
                                <div className="w-full flex gap-3">
                                    {modal.type !== 'gameover' && <button onClick={() => closeModal()} className="flex-1 bg-slate-700 text-slate-300 font-black py-4 rounded-2xl border border-slate-600">ÂèñÊ∂à</button>}
                                    <button onClick={() => { modal.onConfirm(); closeModal(); }} className="flex-1 bg-rose-600 text-white font-black py-4 rounded-2xl border border-rose-500">Á¢∫Ë™ç</button>
                                </div>
                            </React.Fragment>
                        ) : modal.type === 'day_reward' ? (
                            <div className="w-full flex flex-col items-center">
                                <div className="text-amber-500 mb-2"><Icon name="Trophy" size={48} /></div>
                                <h3 className="text-2xl font-black text-slate-100 mb-1">ÂÜíÈö™ÈáåÁ®ãÁ¢ë</h3>
                                <div className="text-sm text-slate-400 font-bold mb-6">Day {modal.day} ÁçéÂãµ</div>
                                
                                <div className="w-full grid grid-cols-3 gap-3 mb-8">
                                    {modal.rewards.map((r, i) => (
                                        <div key={i} className="bg-slate-900 p-3 rounded-2xl border border-slate-700 flex flex-col items-center text-center gap-2">
                                            <div className="text-amber-400"><Icon name={r.icon} size={32} /></div>
                                            <div>
                                                <div className="text-xs font-black text-slate-200 leading-tight">{r.name}</div>
                                                <div className="text-[10px] text-slate-500 font-bold mt-1">{r.desc}</div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                <button onClick={() => closeModal()} className="w-full bg-green-600 text-white font-black py-4 rounded-2xl border-b-4 border-green-800 active:border-b-0 active:translate-y-1 transition-all">È†òÂèñÁçéÂãµ</button>
                            </div>
                        ) : modal.type === 'cave_confirm' ? (
                            <div className="w-full flex flex-col items-center">
                                <div className="text-purple-400 mb-4 animate-bounce"><Icon name="Wind" size={48} /></div>
                                <h3 className="text-xl font-black text-slate-100 mb-2">ÁôºÁèæÁ•ûÁßòÊ¥ûÁ©¥</h3>
                                <p className="text-sm text-slate-400 text-center mb-8 font-bold leading-relaxed">Ê¥ûÁ©¥Ê∑±ËôïÂÇ≥‰æÜÂ•áÊÄ™ÁöÑËÅ≤Èü≥...<br/>ÂèØËÉΩËóèÊúâÂØ∂ËóèÔºå‰πüÂèØËÉΩÊúâÂç±Èö™„ÄÇ<br/>Ë¶ÅÈÄ≤ÂéªÊé¢Á¥¢ÂóéÔºü</p>
                                <div className="w-full flex gap-3">
                                    <button onClick={() => handleCaveDecision(false)} className="flex-1 bg-slate-700 text-slate-300 font-black py-4 rounded-2xl border border-slate-600">Èõ¢Èñã</button>
                                    <button onClick={() => handleCaveDecision(true)} className="flex-1 bg-purple-600 text-white font-black py-4 rounded-2xl border border-purple-500">ÈÄ≤ÂÖ•Êé¢Á¥¢</button>
                                </div>
                            </div>
                        ) : modal.type === 'data_transfer' ? (
                            <div className="w-full">
                                <h3 className="text-2xl font-black text-slate-100 italic mb-4">Â≠òÊ™îÂÇô‰ªΩËàáÈÇÑÂéü</h3>
                                <div className="space-y-4 max-h-[400px] overflow-y-auto pr-2 scrollbar-hide">
                                    <div className="bg-slate-900 p-4 rounded-2xl border border-slate-700">
                                        <div className="font-black text-slate-200 mb-2 flex items-center gap-2"><Icon name="Download" size={18} /> Ê™îÊ°àÂ≠òÂèñ</div>
                                        <p className="text-xs text-slate-400 mb-3">‰∏ãËºâÊàñ‰∏äÂÇ≥ .txt Â≠òÊ™îÊñá‰ª∂„ÄÇ</p>
                                        <div className="flex gap-2">
                                            <button onClick={downloadSaveFile} className="flex-1 bg-blue-600 text-white font-black py-2 rounded-xl text-xs hover:bg-blue-500 transition-colors">‰∏ãËºâÊ™îÊ°à</button>
                                            <label className="flex-1 bg-slate-700 text-slate-300 font-black py-2 rounded-xl text-xs hover:bg-slate-600 transition-colors cursor-pointer flex items-center justify-center">
                                                ÂåØÂÖ•Ê™îÊ°à
                                                <input type="file" accept=".txt" onChange={handleFileImport} className="hidden" />
                                            </label>
                                        </div>
                                    </div>

                                    <div className="flex items-center gap-2">
                                        <div className="h-px bg-slate-600 flex-1"></div>
                                        <span className="text-xs font-bold text-slate-500">OR</span>
                                        <div className="h-px bg-slate-600 flex-1"></div>
                                    </div>

                                    <div className="bg-slate-900 p-4 rounded-2xl border border-slate-700">
                                        <div className="font-black text-slate-200 mb-2 flex items-center gap-2"><Icon name="ScrollText" size={18} /> ‰ª£Á¢ºÂ≠òÂèñ</div>
                                        <p className="text-xs text-slate-400 mb-3">Ë§áË£ΩÂ≠òÊ™î‰ª£Á¢ºÊàñË≤º‰∏ä‰ª£Á¢º‰ª•ÈÇÑÂéü„ÄÇ</p>
                                        
                                        {handleCopySaveToClipboard && (
                                            <button onClick={handleCopySaveToClipboard} className="w-full bg-emerald-600 text-white font-black py-2 rounded-xl text-xs hover:bg-emerald-500 transition-colors mb-4 flex items-center justify-center gap-2">
                                                <Icon name="Copy" size={14} /> Ë§áË£ΩÁõÆÂâçÂ≠òÊ™î‰ª£Á¢º
                                            </button>
                                        )}

                                        <textarea 
                                            value={importCode}
                                            onChange={(e) => setImportCode(e.target.value)}
                                            placeholder="Âú®Ê≠§Ë≤º‰∏äÂ≠òÊ™î‰ª£Á¢º..."
                                            className="w-full bg-slate-800 text-slate-300 text-xs p-3 rounded-xl border border-slate-600 focus:border-orange-500 outline-none resize-none h-24 mb-2 font-mono"
                                        />
                                        {handleImportData && (
                                            <button 
                                                onClick={() => handleImportData(importCode)} 
                                                disabled={!importCode.trim()}
                                                className={`w-full font-black py-2 rounded-xl text-xs transition-colors ${!importCode.trim() ? 'bg-slate-700 text-slate-500 cursor-not-allowed' : 'bg-orange-500 text-white hover:bg-orange-400'}`}
                                            >
                                                ËºâÂÖ•‰ª£Á¢º
                                            </button>
                                        )}
                                    </div>
                                </div>
                                <button onClick={() => closeModal()} className="w-full mt-4 bg-slate-700 text-slate-300 font-black py-3 rounded-2xl border border-slate-600">ÈóúÈñâ</button>
                            </div>
                        ) : (
                            <div className="w-full">
                                <div className="flex justify-between items-center mb-6">
                                    <h3 className="text-2xl font-black text-slate-100 italic">‰øÆÊîπÊó•Ë™å</h3>
                                    <button onClick={() => closeModal()} className="text-slate-400 font-bold text-xl">‚úï</button>
                                </div>
                                <div className="max-h-[400px] overflow-y-auto space-y-6 scrollbar-hide">
                                    {CHANGE_LOGS.map((log, i) => (
                                        <div key={i} className="border-l-4 border-slate-700 pl-4">
                                            <div className="font-black text-slate-200 mb-2">{log.ver}</div>
                                            <ul className="space-y-1">
                                                {log.changes.map((c, ci) => <li key={ci} className="text-xs text-slate-300 font-bold">‚Ä¢ {c}</li>)}
                                            </ul>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // ==================== APP ====================
        const App = () => {
            const [scale, setScale] = useState(1);
            const [view, setView] = useState('menu');
            const [inventoryTab, setInventoryTab] = useState('All');
            const [day, setDay] = useState(1);
            const [stepProgress, setStepProgress] = useState(0); 
            const [hasSave, setHasSave] = useState(false);
            const [bgMode, setBgMode] = useState(BACKGROUNDS[0]);
            
            const [playerBase, setPlayerBase] = useState({
                level: 1,
                initialStats: { atk: 10, def: 2, hp: 100 },
                allocated: { atk: 0, def: 0, hp: 0 },
                statPoints: 0,
                hp: 100, maxHp: 100,
                gold: 1000,
                exp: 0, maxExp: 100, crit: 0.05, evade: 0.05,
                potions: 0, paralyzePotions: 0, doublePotions: 0,
                stats: { kills: 0, totalGold: 0, upgrades: 0, maxDay: 0 },
                unlockedTitles: ['ËèúÈ≥•ÂÜíÈö™ÂÆ∂'],
                title: 'ËèúÈ≥•ÂÜíÈö™ÂÆ∂',
                nextBattleBlessing: false
            });

            const [inventory, setInventory] = useState([
                { ...ITEM_POOL[0], uid: 'init_01', level: 1, exp: 0 },
                { ...ITEM_POOL[4], uid: 'init_02', level: 1, exp: 0 }
            ]);
            const [equipped, setEquipped] = useState({
                weapon: null, head: null, body: null, trinket: null, ring: null, shoes: null
            });
            const [newItems, setNewItems] = useState([]);
            const [upgradeTarget, setUpgradeTarget] = useState(null);
            const [fodderIds, setFodderIds] = useState([]);
            const [highlightedSlot, setHighlightedSlot] = useState(null);
            
            const [gameState, setGameState] = useState('idle');
            const [enemies, setEnemies] = useState([]);
            const [combatStep, setCombatStep] = useState(0);
            const [damages, setDamages] = useState([]);
            const [logs, setLogs] = useState([]);
            const [playerAction, setPlayerAction] = useState('idle');
            const [activeEnemyUid, setActiveEnemyUid] = useState(null);
            const [turnLock, setTurnLock] = useState(false);
            
            const [isAutoAttack, setIsAutoAttack] = useState(false);
            const [isAutoAdventure, setIsAutoAdventure] = useState(false);
            const [autoPotionEnabled, setAutoPotionEnabled] = useState(false);
            const [autoSave, setAutoSave] = useState(false);
            const [lastAutoSaveId, setLastAutoSaveId] = useState(null);
            const [potionCooldown, setPotionCooldown] = useState(false);
            const [hasWarnedNoPotion, setHasWarnedNoPotion] = useState(false);
            
            const [lastEvent, setLastEvent] = useState(null);
            const [nonBattleCount, setNonBattleCount] = useState(0);
            const [turnCount, setTurnCount] = useState(1);
            const [playerBlessedTurns, setPlayerBlessedTurns] = useState(0);
            const [playerDoubleStrikeTurns, setPlayerDoubleStrikeTurns] = useState(0);
            const [needsResume, setNeedsResume] = useState(false);

            const [modal, setModal] = useState(null);
            const [modalQueue, setModalQueue] = useState([]);
            const [toast, setToast] = useState(null);
            const [levelUpOptions, setLevelUpOptions] = useState([]);

            const interactionLock = useRef(false);
            const turnProcessing = useRef(false);
            const victoryProcessing = useRef(false);

            useEffect(() => {
                if (!modal && modalQueue.length > 0) {
                    const nextModal = modalQueue[0];
                    setModal(nextModal);
                    setModalQueue(prev => prev.slice(1));
                }
            }, [modal, modalQueue]);

            const showModal = (newModalData) => setModalQueue(prev => [...prev, newModalData]);
            const closeModal = () => setModal(null);

            useEffect(() => {
                const save = safeLocalStorage.getItem('pikachu_save');
                if (save) setHasSave(true);
            }, []);

            const player = useMemo(() => {
                const baseAtk = (playerBase.initialStats?.atk || 10) + (playerBase.allocated?.atk || 0);
                const baseDef = (playerBase.initialStats?.def || 2) + (playerBase.allocated?.def || 0);
                const baseMaxHp = (playerBase.initialStats?.hp || 100) + ((playerBase.allocated?.hp || 0) * 10); 

                let bonusAtk = 0, bonusDef = 0, bonusMaxHp = 0;
                let bonusCrit = 0, bonusEvade = 0;
                Object.values(equipped).forEach(item => {
                    if (item) {
                        const stats = getItemStats(item);
                        bonusAtk += stats.atk;
                        bonusDef += stats.def;
                        bonusMaxHp += stats.hp;
                        if (item.evade) bonusEvade += item.evade;
                        if (item.effects) {
                            item.effects.forEach(e => {
                                if (e.type === 'crit_burst') bonusCrit += (e.val || 0);
                                if (e.type === 'evade_phantom') bonusEvade += (e.val || 0);
                            });
                        }
                    }
                });

                const currentTitleObj = ACHIEVEMENTS.find(a => a.title === playerBase.title);
                if (currentTitleObj && currentTitleObj.buff) {
                    if (currentTitleObj.buff.atk) bonusAtk += currentTitleObj.buff.atk;
                    if (currentTitleObj.buff.def) bonusDef += currentTitleObj.buff.def;
                    if (currentTitleObj.buff.hp) bonusMaxHp += currentTitleObj.buff.hp;
                    if (currentTitleObj.buff.crit) bonusCrit += currentTitleObj.buff.crit;
                    if (currentTitleObj.buff.evade) bonusEvade += currentTitleObj.buff.evade;
                }

                let finalAtk = baseAtk + bonusAtk;
                let finalDef = baseDef + bonusDef;

                if (gameState === 'combat' && playerBlessedTurns > 0) {
                    finalAtk *= 2;
                    finalDef *= 2;
                }
                
                const totalMaxHp = baseMaxHp + bonusMaxHp;

                return {
                    ...playerBase,
                    atk: finalAtk,
                    def: finalDef,
                    maxHp: totalMaxHp,
                    hp: Math.min(playerBase.hp, totalMaxHp),
                    crit: playerBase.crit + bonusCrit,
                    evade: playerBase.evade + bonusEvade
                };
            }, [playerBase, equipped, gameState, playerBlessedTurns]);

            const getScore = (item) => {
                const stats = getItemStats(item);
                let score = stats.atk + stats.def + (stats.hp / 5);
                if (item.effects && item.effects.length > 0) score += item.effects.length * 50; 
                if (item.rarity === 'Legendary') score += 200;
                return score;
            };

            const filteredInventory = useMemo(() => {
                return inventory.filter(item => {
                    if (upgradeTarget) {
                        if (item.uid === upgradeTarget.uid) return false;
                        const isEquipped = Object.values(equipped).some(e => e && e.uid === item.uid);
                        if (isEquipped) return false;
                    }
                    if (inventoryTab === 'All') return true;
                    return item.slot === inventoryTab.toLowerCase();
                }).sort((a, b) => getScore(b) - getScore(a)); 
            }, [inventory, inventoryTab, upgradeTarget, equipped]);

            useEffect(() => {
                const updateScale = () => {
                    const baseW = 400, baseH = 711;
                    setScale(Math.min(window.innerWidth / baseW, window.innerHeight / baseH, 1.2) * 0.95);
                };
                window.addEventListener('resize', updateScale);
                updateScale();
                return () => window.removeEventListener('resize', updateScale);
            }, []);

            useEffect(() => {
                if (isAutoAttack && gameState === 'combat' && combatStep === 0 && !turnLock && !interactionLock.current && !needsResume && !modal && enemies.length > 0) {
                    const t = setTimeout(() => {
                        handlePlayerAttack();
                    }, 800); 
                    return () => clearTimeout(t);
                }
            }, [isAutoAttack, gameState, combatStep, turnLock, needsResume, modal, enemies]);

            useEffect(() => {
                if (isAutoAdventure && gameState === 'idle' && !needsResume && !modal && !interactionLock.current) {
                    const t = setTimeout(() => {
                        handleNextStep();
                    }, 500); 
                    return () => clearTimeout(t);
                }
            }, [isAutoAdventure, gameState, needsResume, modal, interactionLock.current]);

            useEffect(() => {
                if (gameState === 'combat' && autoPotionEnabled && player.hp > 0 && player.hp < player.maxHp * 0.4) {
                    if (potionCooldown) return;
                    if (playerBase.potions > 0) {
                        const healAmount = Math.floor(player.maxHp * 0.5);
                        setPlayerBase(p => ({
                            ...p,
                            hp: Math.min(player.maxHp, p.hp + healAmount),
                            potions: p.potions - 1
                        }));
                        setPotionCooldown(true);
                        setTimeout(() => setPotionCooldown(false), 1000);
                        addDamage(healAmount, 'player', false, true);
                        addLog(`ü©π Ëá™ÂãïÂñùÊ∞¥ÔºÅÊÅ¢Âæ©‰∫Ü ${healAmount} ÁîüÂëΩÔºÅ`, "success");
                    } else {
                        if (!hasWarnedNoPotion) {
                            setToast({ text: "ÁîüÂëΩËó•Ê∞¥‰∏çË∂≥ÔºÅ", icon: "Skull", duration: 1000 }); 
                            setTimeout(() => setToast(null), 1000);
                            setHasWarnedNoPotion(true);
                        }
                    }
                }
            }, [player.hp, gameState, autoPotionEnabled, playerBase.potions, potionCooldown, hasWarnedNoPotion, player.maxHp]);

            useEffect(() => {
                if (!isAutoAttack) setHasWarnedNoPotion(false);
            }, [isAutoAttack]);

            useEffect(() => {
                if (autoSave && gameState === 'combat' && enemies.length > 0 && enemies[0].uid !== lastAutoSaveId) {
                    setLastAutoSaveId(enemies[0].uid);
                    saveGame(undefined, true);
                    addLog("üíæ Ëá™ÂãïÂ≠òÊ™îÂÆåÊàê", "system");
                }
            }, [gameState, enemies, autoSave]);

            useEffect(() => {
                setPlayerBase(prev => {
                    const currentStats = prev.stats || { kills: 0, totalGold: 0, upgrades: 0, maxDay: 0 };
                    const nextTitles = [...(prev.unlockedTitles || [])];
                    let hasNewTitle = false;
                    let newestTitle = '';

                    const checkAchievement = (ach) => {
                        if (nextTitles.includes(ach.title)) return;
                        let currentVal = 0;
                        if (ach.category === 'combat') currentVal = currentStats.kills || 0;
                        if (ach.category === 'adventure') currentVal = day;
                        if (ach.category === 'wealth') currentVal = currentStats.totalGold || 0;
                        if (ach.category === 'growth') currentVal = currentStats.upgrades || 0;

                        if (currentVal >= ach.target) {
                            nextTitles.push(ach.title);
                            hasNewTitle = true;
                            newestTitle = ach.title;
                        }
                    };

                    ACHIEVEMENTS.forEach(checkAchievement);

                    if (hasNewTitle) {
                        setTimeout(() => showObtainedToast(`Áç≤ÂæóÁ®±Ëôü: ${newestTitle}`, "Trophy"), 1000);
                        return { ...prev, unlockedTitles: nextTitles };
                    }
                    return prev;
                });
            }, [day, playerBase.stats, playerBase.gold]);

            const addLog = (text, type = "info") => {
                setLogs(prev => [...prev, { id: generateId(), text, type }].slice(-50));
            };

            const addDamage = (val, side, isCrit = false, isMiss = false, targetUid = null) => {
                const id = generateId();
                setDamages(prev => [...prev, { id, val, side, isCrit, isMiss, targetUid }]);
                setTimeout(() => setDamages(prev => prev.filter(d => d.id !== id)), 800);
            };

            const showObtainedToast = (text, icon) => {
                setToast({ text, icon });
                setTimeout(() => setToast(null), 1800);
            };

            const resetGame = () => {
                setDay(1); 
                setStepProgress(0); 
                setPlayerBase({ 
                    level: 1, 
                    initialStats: { atk: 10, def: 2, hp: 100 },
                    allocated: { atk: 0, def: 0, hp: 0 },
                    statPoints: 0,
                    hp: 100, maxHp: 100,
                    gold: 1000, 
                    exp: 0, maxExp: 100, crit: 0.05, evade: 0.05, 
                    potions: 0, paralyzePotions: 0, doublePotions: 0,
                    stats: { kills: 0, totalGold: 0, upgrades: 0, maxDay: 0 },
                    unlockedTitles: ['ËèúÈ≥•ÂÜíÈö™ÂÆ∂'],
                    title: 'ËèúÈ≥•ÂÜíÈö™ÂÆ∂',
                    nextBattleBlessing: false
                });
                setInventory([{ ...ITEM_POOL[0], uid: 'init_01', level: 1, exp: 0 }, { ...ITEM_POOL[4], uid: 'init_02', level: 1, exp: 0 }]);
                setEquipped({ weapon: null, head: null, body: null, trinket: null, ring: null, shoes: null });
                setNewItems([]);
                setGameState('idle');
                setNeedsResume(false);
                setEnemies([]);
                setLogs([{ id: '0', text: "ÁöÆÂç°‰∏òÂÜíÈö™ÈáçÊñ∞ÈñãÂßãÔºÅÁ•ù‰Ω†Â•ΩÈÅã„ÄÇ", type: "system" }]);
                setBgMode(BACKGROUNDS[0]); 
                setView('adventure');
                setModal(null); 
                setModalQueue([]);
                setUpgradeTarget(null);
                setPlayerDoubleStrikeTurns(0);
                setPlayerBlessedTurns(0);
                setPlayerAction('idle');
                setActiveEnemyUid(null);
                setLastEvent(null); 
                setTurnCount(1); 
                setNonBattleCount(0);
                interactionLock.current = false;
                victoryProcessing.current = false;
                setTurnLock(false);
                setIsAutoAttack(false);
                setIsAutoAdventure(false); 
                setHighlightedSlot(null);
                setLastAutoSaveId(null);
                setAutoPotionEnabled(false);
                setHasWarnedNoPotion(false);
            };

            const getSaveObject = () => {
                const safeLogs = logs.filter(l => typeof l.text === 'string').slice(-20);
                return { 
                    playerBase, inventory, equipped, day, logs: safeLogs, bgMode,
                    gameState, enemies, needsResume, turnCount, playerBlessedTurns,
                    autoSave, autoPotionEnabled, nonBattleCount, stepProgress 
                };
            };

            const saveGame = (onSuccess, silent = false) => {
                const saveData = getSaveObject();
                // Attempt Local Storage (might fail in file:// context)
                const savedToStorage = safeLocalStorage.setItem('pikachu_save', JSON.stringify(saveData));
                
                if (savedToStorage) {
                    setHasSave(true);
                    if (!silent) showObtainedToast("ÈÄ≤Â∫¶Â∑≤ÂÑ≤Â≠ò (Local)", "Save");
                } else {
                    // Fallback for file:// protocol or private browsing
                    if (!silent) {
                        showModal({ type: 'data_transfer' });
                        setTimeout(() => alert("‚ö†Ô∏è Ê≥®ÊÑèÔºöÁÄèË¶ΩÂô®ÈôêÂà∂‰∫ÜËá™ÂãïÂ≠òÊ™îÂäüËÉΩ (ÂèØËÉΩÊòØÂõ†ÁÇ∫Áõ¥Êé•ÈñãÂïü HTML Ê™îÊ°à)„ÄÇ\n\nË´ãÈªûÊìä„Äå‰∏ãËºâÊ™îÊ°à„Äç‰æÜÊâãÂãï‰øùÂ≠òÊÇ®ÁöÑÈÄ≤Â∫¶ÔºÅ"), 100);
                    }
                }

                if (onSuccess && typeof onSuccess === 'function') onSuccess();
                else if (view === 'menu' && savedToStorage) closeModal();
            };

            const loadGame = () => {
                try {
                    const json = safeLocalStorage.getItem('pikachu_save');
                    if (json) {
                        const saveData = JSON.parse(json);
                        if (saveData) {
                            let loadedPlayerBase = { ...saveData.playerBase };
                            if (!loadedPlayerBase.initialStats || !loadedPlayerBase.allocated) {
                                const level = loadedPlayerBase.level || 1;
                                loadedPlayerBase.initialStats = { atk: 10, def: 2, hp: 100 };
                                loadedPlayerBase.allocated = { atk: 0, def: 0, hp: 0 };
                                loadedPlayerBase.statPoints = (level - 1) * POINTS_PER_LEVEL;
                                addLog("‚ö†Ô∏è Á≥ªÁµ±ÂçáÁ¥öÔºöÂ±¨ÊÄßÈªûÊï∏Â∑≤ÈáçÁΩÆÔºåË´ãÈáçÊñ∞ÂàÜÈÖçÔºÅ", "special");
                            }
                            if (saveData.playerBase) {
                                setPlayerBase(prev => ({
                                    ...prev,
                                    ...loadedPlayerBase,
                                    paralyzePotions: loadedPlayerBase.paralyzePotions || loadedPlayerBase.stunPotions || 0,
                                    doublePotions: loadedPlayerBase.doublePotions || 0,
                                    stats: { kills: 0, totalGold: 0, upgrades: 0, maxDay: 0, ...loadedPlayerBase.stats },
                                    unlockedTitles: loadedPlayerBase.unlockedTitles || ['ËèúÈ≥•ÂÜíÈö™ÂÆ∂'],
                                    title: loadedPlayerBase.title || 'ËèúÈ≥•ÂÜíÈö™ÂÆ∂',
                                    nextBattleBlessing: loadedPlayerBase.nextBattleBlessing || false
                                }));
                            }
                            const fixItem = (item) => {
                                if (!item) return null;
                                const newItem = { ...item, level: item.level || 1, exp: item.exp || 0 };
                                if (newItem.effect && !newItem.effects) {
                                    newItem.effects = [newItem.effect];
                                    delete newItem.effect;
                                }
                                if (!newItem.effects) newItem.effects = [];
                                newItem.effects = newItem.effects.map(e => {
                                    if (e.val === undefined) {
                                        if (e.type === 'crit_burst' || e.type === 'evade_phantom') return { ...e, val: 0.25 }; 
                                        return { ...e, val: getEffectChance(e.type) };
                                    }
                                    return e;
                                });
                                return newItem;
                            };
                            if (saveData.inventory && Array.isArray(saveData.inventory)) {
                                setInventory(saveData.inventory.map(fixItem).filter(i => i !== null));
                            }
                            const fixedEquipped = {};
                            if (saveData.equipped) {
                                Object.keys(saveData.equipped).forEach(key => {
                                    fixedEquipped[key] = saveData.equipped[key] ? fixItem(saveData.equipped[key]) : null;
                                });
                                setEquipped(prev => ({ ...prev, ...fixedEquipped }));
                            }
                            setDay(saveData.day || 1);
                            setStepProgress(saveData.stepProgress || 0); 
                            const loadedLogs = (saveData.logs || []).filter(l => typeof l.text === 'string');
                            setLogs(loadedLogs);
                            if(saveData.bgMode) setBgMode(saveData.bgMode);
                            if (saveData.gameState) setGameState(saveData.gameState);
                            else setGameState('idle');
                            if (saveData.enemies && Array.isArray(saveData.enemies)) setEnemies(saveData.enemies);
                            if (saveData.needsResume !== undefined) setNeedsResume(saveData.needsResume);
                            else setNeedsResume(false);
                            if (saveData.autoSave !== undefined) setAutoSave(saveData.autoSave);
                            if (saveData.autoPotionEnabled !== undefined) setAutoPotionEnabled(saveData.autoPotionEnabled);
                            setNonBattleCount(saveData.nonBattleCount || 0);

                            setView('adventure');
                            setTurnLock(false);
                            setIsAutoAttack(false);
                            setIsAutoAdventure(false); 
                            setLastEvent(null);
                            setTurnCount(saveData.turnCount || 1);
                            setPlayerBlessedTurns(saveData.playerBlessedTurns || 0);
                            setHighlightedSlot(null);
                            setNewItems([]);
                            setLastAutoSaveId(null);
                            setHasWarnedNoPotion(false);
                            addLog("üìÇ ÊàêÂäüËÆÄÂèñÈÄ≤Â∫¶ÔºÅ", "system");
                        }
                    } else alert("Êâæ‰∏çÂà∞Â≠òÊ™îÔºÅ");
                } catch (e) { console.error(e); alert("ËÆÄÂèñÂ≠òÊ™îÂ§±ÊïóÔºÅÂèØËÉΩÊòØÂ≠òÊ™îÊêçÊØÄ„ÄÇ"); }
            };

            const grantExp = (amount) => {
                setPlayerBase(p => {
                    const nextExp = p.exp + amount;
                    if (nextExp >= p.maxExp) {
                        const options = [];
                        const randomItem = generateScaledItem(ITEM_POOL[Math.floor(Math.random() * ITEM_POOL.length)], day, p.level + 1);
                        options.push({ type: 'item', val: randomItem, label: "Èö®Ê©üË£ùÂÇô", desc: `Lv.${randomItem.level} ${randomItem.name}`, icon: "Box" });
                        const randomGold = Math.floor(300 + Math.random() * 201); 
                        options.push({ type: 'gold', val: randomGold, label: "Ë±êÂéöÈáëÂπ£", desc: `ÈáëÂπ£ +${randomGold}`, icon: "Coins" });
                        const randomPotions = Math.floor(2 + Math.random() * 2); 
                        options.push({ type: 'potion', val: randomPotions, label: "Ë£úÁµ¶Áâ©Ë≥á", desc: `ÁîüÂëΩËó•Ê∞¥ +${randomPotions}`, icon: "Coffee" });
                        setLevelUpOptions(options);
                        setGameState('levelup');
                        setModal({ type: 'levelup' }); 
                        return { 
                            ...p, 
                            level: p.level + 1,
                            exp: 0, 
                            maxExp: Math.floor(p.maxExp * 1.2),
                            statPoints: (p.statPoints || 0) + POINTS_PER_LEVEL
                        };
                    }
                    return { ...p, exp: nextExp };
                });
            };

            const handleLevelUpChoice = (option) => {
                if (option.type === 'item') {
                    setInventory(prev => [...prev, option.val]);
                    setNewItems(prev => [...prev, option.val.uid]);
                    addLog(`üÜô ÂçáÁ¥öÁçéÂãµÔºÅÁç≤ÂæóË£ùÂÇô [${option.val.name}]„ÄÇ`, "special");
                } else if (option.type === 'gold') {
                    setPlayerBase(p => ({ ...p, gold: p.gold + option.val, stats: { ...p.stats, totalGold: (p.stats.totalGold || 0) + option.val } }));
                    addLog(`üÜô ÂçáÁ¥öÁçéÂãµÔºÅÁç≤ÂæóÈáëÂπ£ ${option.val}„ÄÇ`, "special");
                } else if (option.type === 'potion') {
                    setPlayerBase(p => ({ ...p, potions: p.potions + option.val }));
                    addLog(`üÜô ÂçáÁ¥öÁçéÂãµÔºÅÁç≤ÂæóÁîüÂëΩËó•Ê∞¥ x${option.val}„ÄÇ`, "special");
                }
                showObtainedToast("Á≠âÁ¥öÊèêÂçáÔºÅ", "ArrowUp");
                setGameState('idle');
                closeModal();
            };

            const usePotion = (type) => {
                if (type === 'heal') {
                    if (playerBase.potions > 0 && player.hp < player.maxHp) {
                        const healAmount = Math.floor(player.maxHp * 0.5);
                        setPlayerBase(p => ({
                            ...p,
                            hp: Math.min(player.maxHp, p.hp + healAmount),
                            potions: p.potions - 1
                        }));
                        addDamage(healAmount, 'player', false, true);
                        addLog(`ü©π ‰ΩøÁî®Ëó•Ê∞¥ÔºåÊÅ¢Âæ©‰∫Ü ${healAmount} ÁîüÂëΩÔºÅ`, "success");
                        showObtainedToast("ÊÅ¢Âæ©ÁîüÂëΩ", "Coffee");
                    } else if (player.hp >= player.maxHp) {
                        addLog("ÁîüÂëΩÂÄºÂ∑≤ÊªøÔºåÁÑ°ÈúÄ‰ΩøÁî®Ëó•Ê∞¥„ÄÇ", "info");
                    }
                } else if (type === 'paralyze') {
                    if (gameState !== 'combat') {
                        addLog("È∫ªÁó∫Ëó•Ê∞¥Âè™ËÉΩÂú®Êà∞È¨•‰∏≠‰ΩøÁî®ÔºÅ", "info");
                        return;
                    }
                    if (playerBase.paralyzePotions > 0) {
                        setPlayerBase(p => ({ ...p, paralyzePotions: p.paralyzePotions - 1 }));
                        setEnemies(prev => prev.map(e => ({ ...e, paralyzedTurns: 2 })));
                        addLog(`‚ö° ‰ΩøÁî®È∫ªÁó∫Ëó•Ê∞¥ÔºÅÊâÄÊúâÊïµ‰∫∫Â∞áÈÄ≤ÂÖ•È∫ªÁó∫ÁãÄÊÖã 2 ÂõûÂêà„ÄÇ`, "special");
                        showObtainedToast("Áæ§È´îÈ∫ªÁó∫", "Zap");
                    }
                } else if (type === 'double') {
                    if (gameState !== 'combat') {
                        addLog("ÈÄ£ÊìäËó•Ê∞¥Âè™ËÉΩÂú®Êà∞È¨•‰∏≠‰ΩøÁî®ÔºÅ", "info");
                        return;
                    }
                    if (playerBase.doublePotions > 0) {
                        setPlayerBase(p => ({ ...p, doublePotions: p.doublePotions - 1 }));
                        setPlayerDoubleStrikeTurns(2);
                        addLog(`‚öîÔ∏è ‰ΩøÁî®ÈÄ£ÊìäËó•Ê∞¥ÔºÅÊîªÊìäÂ∞áËß∏Áôº 2 Ê¨°ÔºåÊåÅÁ∫å 2 ÂõûÂêà„ÄÇ`, "special");
                        showObtainedToast("ÈÄ£ÊìäÊïàÊûú", "Swords");
                    }
                }
            };

            const triggerEvent = (type, currentDay) => {
                const dailyExp = 15 + currentDay * 2;
                if (type === 'cave') {
                    showModal({ type: 'cave_confirm' });
                    return;
                }
                if (type === 'statue') {
                    if (player.hp < player.maxHp * 0.5) {
                        setPlayerBase(p => ({ ...p, hp: player.maxHp }));
                        addLog("üôè ËôîË™†Âú∞ÂêëË∑ØÈÇäÁöÑÁ•ûÂÉèÁ•àÁ¶±... Á•ûÂÉèÁôºÂá∫ÊüîÂíåÁöÑÂÖâËäíÔºåÂÇ∑Âè£ÂÆåÂÖ®ÁôíÂêà‰∫ÜÔºÅ", "success");
                        showObtainedToast("ÁîüÂëΩÂÖ®Êªø", "HeartPulse");
                    } else {
                        setPlayerBase(p => ({ ...p, nextBattleBlessing: true }));
                        addLog("üôè ËôîË™†Âú∞ÂêëË∑ØÈÇäÁöÑÁ•ûÂÉèÁ•àÁ¶±... ÊÑüË¶∫È´îÂÖßÂÖÖÊªø‰∫ÜÂäõÈáèÔºÅ(‰∏ãÊ¨°Êà∞È¨•Ââç2ÂõûÂêàËÉΩÂäõÁøªÂÄç)", "special");
                        showObtainedToast("Êà∞Á•ûÁ•ùÁ¶è", "Swords");
                    }
                    grantExp(dailyExp);
                } else if (type === 'trip') {
                    const totalPotions = playerBase.potions + playerBase.paralyzePotions + playerBase.doublePotions;
                    const isEffectA = totalPotions > 0 && Math.random() < 0.5;
                    if (isEffectA) {
                        const breakCount = Math.min(totalPotions, Math.floor(Math.random() * 3) + 1);
                        let remainingToBreak = breakCount;
                        let brokenList = []; 
                        let currentPotions = playerBase.potions;
                        let currentParalyze = playerBase.paralyzePotions;
                        let currentDouble = playerBase.doublePotions;
                        if (remainingToBreak > 0 && currentPotions > 0) {
                            const remove = Math.min(currentPotions, remainingToBreak);
                            currentPotions -= remove;
                            remainingToBreak -= remove;
                            brokenList.push({ name: "ÁîüÂëΩËó•Ê∞¥", count: remove });
                        }
                        if (remainingToBreak > 0 && currentParalyze > 0) {
                            const remove = Math.min(currentParalyze, remainingToBreak);
                            currentParalyze -= remove;
                            remainingToBreak -= remove;
                            brokenList.push({ name: "È∫ªÁó∫Ëó•Ê∞¥", count: remove });
                        }
                        if (remainingToBreak > 0 && currentDouble > 0) {
                            const remove = Math.min(currentDouble, remainingToBreak);
                            currentDouble -= remove;
                            remainingToBreak -= remove;
                            brokenList.push({ name: "ÈÄ£ÊìäËó•Ê∞¥", count: remove });
                        }
                        setPlayerBase(p => ({
                            ...p,
                            potions: currentPotions,
                            paralyzePotions: currentParalyze,
                            doublePotions: currentDouble
                        }));
                        const breakText = brokenList.map(b => `${b.name}x${b.count}`).join('„ÄÅ');
                        addLog(<span>Ëµ∞Ë∑ØÊªëÊâãÊ©ü‰∏çÁúãË∑ØÔºåË∑åÂÄíÁãóÂêÉÂ±éÔºÅËÉåÂåÖË£°ÁöÑÁ¢é‰∫Ü‰∏ÄÂú∞...<br/><span className="text-rose-400">ÊêçÂ§± {breakText}</span></span>, "danger");
                        showObtainedToast("Ëó•Ê∞¥Á†¥Êêç", "Trash");
                    } else {
                        const pct = 0.2 + Math.random() * 0.1;
                        const medicalFee = Math.floor(player.gold * pct);
                        setPlayerBase(p => ({ ...p, gold: Math.max(0, p.gold - medicalFee) }));
                        addLog(`üòµ Ëµ∞Ë∑ØÊªëÊâãÊ©ü‰∏çÁúãË∑ØÔºåË∑åÂÄíÁãóÂêÉÂ±éÔºÅÁ∑äÊÄ•ÈÄÅÈÜ´ÂåÖÁ¥ÆÔºåËä±Ë≤ª‰∫Ü ${medicalFee} ÈáëÂπ£ÈÜ´Ëó•Ë≤ª„ÄÇ`, "danger");
                        showObtainedToast(`ÊêçÂ§± ${medicalFee} ÈáëÂπ£`, "Skull");
                    }
                    grantExp(Math.floor(dailyExp/3)); 
                } else if (type === 'trap') {
                    const minPct = 0.15;
                    const maxPct = 0.30;
                    const dmgPct = minPct + Math.random() * (maxPct - minPct);
                    const dmg = Math.max(1, Math.floor(player.hp * dmgPct));
                    const actualDmg = player.hp - dmg <= 0 ? player.hp - 1 : dmg;
                    if (actualDmg > 0) {
                        setPlayerBase(p => ({ ...p, hp: p.hp - actualDmg }));
                        addDamage(actualDmg, 'player', false, false);
                        addLog(`‚ö†Ô∏è ÂìéÂëÄÔºÅË∏©Âà∞Èô∑Èò±ÂèóÈáçÂÇ∑ÔºåÂèóÂà∞ ${actualDmg} ÈªûÂÇ∑ÂÆ≥ÔºÅ(Exp +${Math.floor(dailyExp/2)})`, "danger");
                    } 
                    grantExp(Math.floor(dailyExp/2));
                } else if (type === 'rest') {
                    const heal = 40 + playerBase.level * 5;
                    setPlayerBase(p => ({ ...p, hp: Math.min(player.maxHp, p.hp + heal) }));
                    addLog(`üçÉ ‰ºëÊÅØÊôÇÈñìÔºöÊÅ¢Âæ©‰∫Ü ${heal} ÁîüÂëΩ (Exp +${dailyExp})„ÄÇ`, "success");
                    grantExp(dailyExp);
                } else {
                    const gold = 75 + currentDay * 10; 
                    setPlayerBase(p => ({ ...p, gold: p.gold + gold, stats: {...p.stats, totalGold: (p.stats.totalGold || 0) + gold} }));
                    addLog(`üí∞ Âπ∏ÈÅãÔºÅÁôºÁèæÂ§ßË¢ãÈáëÂπ£ +${gold} (Exp +${dailyExp})„ÄÇ`, "success");
                    grantExp(dailyExp);
                }
                setGameState(prev => prev === 'levelup' ? 'levelup' : 'idle');
            };

            const handleNextStep = () => {
                if (gameState !== 'idle' || needsResume || interactionLock.current) return;
                interactionLock.current = true;
                setGameState('walking');
                const nextStep = stepProgress + 1;
                setStepProgress(nextStep);
                const currentDayForCalculations = day || 1; 
                
                setTimeout(() => {
                    const forcedBattle = nonBattleCount >= 3;
                    const ALL_EVENTS = ['battle', 'rest', 'chest', 'cave', 'statue', 'trip', 'trap'];
                    let availableEvents = ALL_EVENTS.filter(e => e !== lastEvent);
                    if (availableEvents.length === 0) availableEvents = ALL_EVENTS;
                    let nextType = forcedBattle ? 'battle' : availableEvents[Math.floor(Math.random() * availableEvents.length)];
                    setLastEvent(nextType);
                    if (nextStep % 3 === 0) {
                        const nextDay = day + 1;
                        setDay(nextDay);
                        setStepProgress(0); 
                        addLog(`üìÖ Á¨¨ ${nextDay} Â§©ÔºöÁöÆÂç°‰∏òÁπºÁ∫åÂêëÊú™Áü•ÁöÑÈÅ†ÊñπÂâçË°å...`, "day_change");
                        if (nextDay % 30 === 0) setTimeout(() => openDayReward(nextDay), 600);
                    }
                    if (nextType === 'battle') {
                        setNonBattleCount(0); 
                        triggerBattle(currentDayForCalculations);
                    } else {
                        setNonBattleCount(prev => prev + 1); 
                        triggerEvent(nextType, currentDayForCalculations);
                    }
                    interactionLock.current = false;
                }, 1200);
            };

            const triggerBattle = (currentDay) => {
                const count = currentDay < 5 ? 1 : (Math.random() < 0.5 ? 1 : Math.random() < 0.75 ? 2 : 3);
                const statMulti = count === 1 ? 1 : (count === 2 ? 0.85 : 0.75);
                const newEnemies = [];
                let maxSpecials = 1;
                if (currentDay > 100) maxSpecials = 2;
                let currentSpecials = 0;
                const pAtk = Math.max(10, player.atk || 0); 
                const pDef = player.def || 0;
                const pHp = player.maxHp;
                for (let i = 0; i < count; i++) {
                    let base = ENEMIES_DATA[Math.floor(Math.random() * (Math.min(Math.floor(currentDay/4)+1, ENEMIES_DATA.length)))];
                    if (base.rank > 0) {
                        if (currentSpecials >= maxSpecials) base = ENEMIES_DATA[0]; 
                        else currentSpecials++;
                    }
                    let hpMult, atkDmgPct;
                    if (base.rank === 2) { hpMult = 8; atkDmgPct = 0.08; } 
                    else if (base.rank === 1) { hpMult = 3; atkDmgPct = 0.05; } 
                    else { hpMult = 1.8; atkDmgPct = 0.03; }
                    const hpRng = 0.8 + Math.random() * 0.4;
                    const atkRng = 0.9 + Math.random() * 0.2;
                    let targetHp = Math.floor(pAtk * hpMult * hpRng * statMulti);
                    let targetAtk = Math.floor(pDef + (pHp * atkDmgPct * statMulti * atkRng));
                    let targetDef = Math.floor(pAtk * (0.1 + Math.random() * 0.2));
                    const minHp = 20 + currentDay * 3; 
                    const minAtk = Math.floor(5 + currentDay * 0.5);
                    newEnemies.push({
                        ...base,
                        uid: generateId(),
                        hp: Math.max(minHp, targetHp),
                        maxHp: Math.max(minHp, targetHp),
                        atk: Math.max(minAtk, targetAtk),
                        def: targetDef,
                        paralyzedTurns: 0,
                        burnTurns: 0,
                        weakenedTurns: 0
                    });
                }
                if (playerBase.nextBattleBlessing) {
                    setPlayerBlessedTurns(2);
                    setPlayerBase(p => ({ ...p, nextBattleBlessing: false }));
                    addLog("‚ú® Á•ûÂÉèÁöÑÁ•ùÁ¶èÁîüÊïà‰∫ÜÔºÅÂâçÂÖ©ÂõûÂêàÊîªÊìäËàáÈò≤Á¶¶Âä†ÂÄçÔºÅ", "special");
                } else {
                    setPlayerBlessedTurns(0);
                }
                setHasWarnedNoPotion(false); 
                addLog(`‚ö†Ô∏è Ë≠¶ÂëäÔºÅÈÅ≠ÈÅá‰∫Ü ${count > 1 ? '‰∏ÄÁæ§' : '‰∏ÄÈöª'} Êïµ‰∫∫ÔºÅ`, "danger");
                setEnemies(newEnemies);
                setGameState('combat');
                setIsAutoAdventure(false); 
                setPlayerDoubleStrikeTurns(0);
                setCombatStep(0);
                setTurnCount(1);
            };

            const handlePlayerAttack = async () => {
                if (combatStep !== 0 || playerAction !== 'idle' || interactionLock.current) return; 
                if (enemies.length > 0 && enemies.every(e => e.hp <= 0)) return;
                interactionLock.current = true;
                setTurnLock(true); 
                let totalRegen = 0;
                let regenTriggered = false;
                Object.values(equipped).forEach(item => {
                    if (item && item.effects) {
                        item.effects.forEach(eff => {
                            if (eff.type === 'regen') {
                                const chance = eff.val || 0.35;
                                if (Math.random() < chance) {
                                    regenTriggered = true;
                                    totalRegen += Math.floor(player.maxHp * 0.05);
                                }
                            }
                        });
                    }
                });
                if (regenTriggered && totalRegen > 0) {
                    setPlayerBase(p => {
                        const newHp = Math.min(player.maxHp, p.hp + totalRegen);
                        return { ...p, hp: newHp };
                    });
                    addDamage(totalRegen, 'player', false, true); 
                    addLog(`üå± ÂõûÊò•Ëß∏ÁôºÔºÅÊÅ¢Âæ©‰∫Ü ${totalRegen} ÁîüÂëΩ„ÄÇ`, "success");
                    await sleep(300); 
                }
                const executeAttack = async (currentEnemiesSnapshot) => {
                    setPlayerAction('attacking');
                    await sleep(500); 
                    let nextEnemies = [...currentEnemiesSnapshot];
                    let hasAOE = false;
                    Object.values(equipped).forEach(item => {
                        if (item && item.effects) {
                            item.effects.forEach(e => {
                                if (e.type === 'aoe') {
                                    const chance = e.val || 0.7;
                                    if (Math.random() < chance) hasAOE = true;
                                }
                            });
                        }
                    });
                    let targets = [];
                    if (hasAOE) {
                        nextEnemies.forEach((e, idx) => {
                            if (e.hp > 0) targets.push({ index: idx, enemy: { ...e } });
                        });
                    } else {
                        const targetIndex = nextEnemies.findIndex(e => e.hp > 0);
                        if (targetIndex !== -1) {
                            targets.push({ index: targetIndex, enemy: { ...nextEnemies[targetIndex] } });
                        }
                    }
                    if (targets.length > 0) {
                        targets.forEach(({ index, enemy }) => {
                            let isCrit = Math.random() < player.crit;
                            let isEnemyEvade = Math.random() < (enemy.evade || 0);
                            if (isEnemyEvade) {
                                addDamage(0, 'enemy', false, true, enemy.uid); 
                                addLog(`üí® [${enemy.name}] ÈùàÊ¥ªÂú∞ÈñÉÈÅé‰∫ÜÁöÆÂç°‰∏òÁöÑÊîªÊìäÔºÅ`, "info");
                            } else {
                                let baseAtk = player.atk || 10;
                                let atkVariance = Math.floor(baseAtk * 0.2); 
                                let actualAtk = Math.floor(baseAtk * 0.9) + Math.floor(Math.random() * atkVariance);
                                if (isCrit) actualAtk = Math.floor(actualAtk * 1.5);
                                const effectiveDef = (enemy.weakenedTurns > 0) ? Math.floor((enemy.def || 0) * 0.5) : (enemy.def || 0);
                                const minDmg = 1;
                                let rawDmg = Math.max(minDmg, Math.ceil(actualAtk * 0.1), actualAtk - effectiveDef);
                                Object.values(equipped).forEach(item => {
                                    if (!item || !item.effects) return;
                                    item.effects.forEach(effect => {
                                        if (effect.type === 'aoe') return;
                                        const chance = effect.val || 0.2; 
                                        if (Math.random() < chance) {
                                            if (effect.type === 'paralyze') {
                                                enemy.paralyzedTurns = (enemy.paralyzedTurns || 0) + 1;
                                                addLog(`‚ö° [${item.name}] È∫ªÁó∫ÔºÅ${enemy.name} ÁÑ°Ê≥ïÂãïÂΩàÔºÅ`, "special");
                                            } else if (effect.type === 'fire') {
                                                enemy.burnTurns = (enemy.burnTurns || 0) + 3;
                                                addLog(`üî• [${item.name}] ÁáÉÁáíÔºÅ${enemy.name} ËëóÁÅ´‰∫ÜÔºÅ`, "special");
                                            } else if (effect.type === 'vampire') {
                                                const heal = Math.floor(rawDmg * 0.1);
                                                setPlayerBase(p => ({ ...p, hp: Math.min(player.maxHp, p.hp + heal) }));
                                                addLog(`ü©∏ [${item.name}] Âê∏Ë°ÄÔºÅÊÅ¢Âæ© ${heal} ÁîüÂëΩ„ÄÇ`, "success");
                                            } else if (effect.type === 'weakness') {
                                                enemy.weakenedTurns = (enemy.weakenedTurns || 0) + 2;
                                                addLog(`üíÄ [${item.name}] ËôõÂº±ÔºÅ${enemy.name} ÁöÑÊîªÊìäËàáÈò≤Á¶¶Ê∏õÂçäÔºÅ`, "special");
                                            }
                                        }
                                    });
                                });
                                addDamage(rawDmg, 'enemy', isCrit, false, enemy.uid);
                                enemy.hp = Math.max(0, enemy.hp - rawDmg);
                                const critText = isCrit ? "üî• Êö¥ÊìäÔºÅ" : "";
                                const defLog = rawDmg <= Math.ceil(actualAtk * 0.1) ? '(Ë¢´Ê†ºÊìã)' : '';
                                if (hasAOE) {
                                    addLog(`‚ö° ${critText}ÁöÆÂç°‰∏òÁôºÂãïÂÖ®È´îÊîªÊìäÔºåÂ∞ç [${enemy.name}] ÈÄ†Êàê ${rawDmg} ÈªûÂÇ∑ÂÆ≥${defLog}„ÄÇ`, "special");
                                } else {
                                    addLog(`${critText}ÁöÆÂç°‰∏òÊîªÊìä [${enemy.name}] ÈÄ†Êàê ${rawDmg} ÈªûÂÇ∑ÂÆ≥${defLog}„ÄÇ`, isCrit ? "special" : "attack");
                                }
                            }
                            nextEnemies[index] = enemy;
                        });
                        setEnemies(nextEnemies);
                    }
                    setPlayerAction('idle');
                    await sleep(600); 
                    return nextEnemies;
                };

                try {
                    let finalEnemiesState = await executeAttack(enemies);
                    if (finalEnemiesState.every(e => e.hp <= 0)) {
                        await sleep(1200); 
                        handleVictory();
                        return;
                    } else if (playerDoubleStrikeTurns > 0) {
                        addLog("‚öîÔ∏è ÈÄ£ÊìäËß∏ÁôºÔºÅËøΩÂä†‰∏ÄÊ¨°ÊîªÊìäÔºÅ", "special");
                        await sleep(500); 
                        finalEnemiesState = await executeAttack(finalEnemiesState);
                        setPlayerDoubleStrikeTurns(prev => Math.max(0, prev - 1));
                        if (finalEnemiesState.every(e => e.hp <= 0)) {
                            await sleep(1200); 
                            handleVictory();
                            return;
                        } else {
                            setCombatStep(1);
                        }
                    } else {
                        setCombatStep(1); 
                    }
                } catch(e) {
                    console.error("Combat error", e);
                    setCombatStep(1); 
                } finally {
                    interactionLock.current = false;
                }
            };

            useEffect(() => {
                if (gameState === 'combat' && enemies.length > 0 && player.hp > 0 && !needsResume) {
                    if (combatStep === 1) {
                        if (turnProcessing.current) return;
                        turnProcessing.current = true;
                        const processEnemyTurns = async () => {
                            try {
                                await sleep(400);
                                let currentEnemiesState = [...enemies]; 
                                if (currentEnemiesState.every(e => e.hp <= 0)) {
                                    await sleep(1200);
                                    handleVictory();
                                    return;
                                }
                                for (let i = 0; i < currentEnemiesState.length; i++) {
                                    let enemy = currentEnemiesState[i];
                                    if (enemy.hp <= 0) continue;
                                    if (enemy.burnTurns > 0) {
                                        const burnDmg = Math.max(1, Math.floor(enemy.maxHp * 0.05));
                                        const newHp = Math.max(0, enemy.hp - burnDmg);
                                        const newBurnTurns = enemy.burnTurns - 1;
                                        enemy = { ...enemy, hp: newHp, burnTurns: newBurnTurns };
                                        currentEnemiesState[i] = enemy; 
                                        setEnemies(prev => prev.map(e => e.uid === enemy.uid ? enemy : e));
                                        addDamage(burnDmg, 'enemy', false, false, enemy.uid);
                                        addLog(`üî• ${enemy.name} ÂèóÂà∞ ${burnDmg} ÈªûÁáÉÁáíÂÇ∑ÂÆ≥ÔºÅ`, "hit");
                                        if (newHp <= 0) { 
                                            await sleep(1200); 
                                            if (currentEnemiesState.every(e => e.hp <= 0)) {
                                                handleVictory();
                                                return;
                                            }
                                            continue; 
                                        }
                                        await sleep(300);
                                    }
                                    if (enemy.paralyzedTurns > 0) {
                                        addLog(`‚ö° ${enemy.name} ËôïÊñºÈ∫ªÁó∫ÁãÄÊÖãÔºåÁÑ°Ê≥ïË°åÂãïÔºÅ`, "special");
                                        enemy = { ...enemy, paralyzedTurns: enemy.paralyzedTurns - 1 };
                                        currentEnemiesState[i] = enemy;
                                        setEnemies(prev => prev.map(e => e.uid === enemy.uid ? enemy : e));
                                        await sleep(500);
                                        continue;
                                    }
                                    setActiveEnemyUid(enemy.uid); 
                                    await sleep(500);
                                    let totalDamageToPlayer = 0;
                                    let isMiss = Math.random() < player.evade;
                                    if (isMiss) {
                                        addDamage(0, 'player', false, true);
                                        addLog(`ÁöÆÂç°‰∏òÈñÉÈÅé‰∫Ü ${enemy.name} ÁöÑÊîªÊìäÔºÅ`, "special");
                                    } else {
                                        const weakMod = (enemy.weakenedTurns > 0) ? 0.5 : 1.0;
                                        if (enemy.weakenedTurns > 0) {
                                            enemy.weakenedTurns -= 1;
                                            currentEnemiesState[i] = enemy;
                                            setEnemies(prev => prev.map(e => e.uid === enemy.uid ? enemy : e));
                                        }
                                        let enemyAtk = Math.floor(enemy.atk * weakMod);
                                        let minDmg = Math.floor(enemyAtk * 0.1); 
                                        let baseCalc = Math.max(minDmg, enemyAtk - (player.def || 0));
                                        let variance = Math.floor(Math.random() * (enemyAtk * 0.2));
                                        const dmg = baseCalc + variance;
                                        totalDamageToPlayer += dmg;
                                        addLog(`${enemy.name} ÁôºÂãïÊîªÊìäÔºåÈÄ†Êàê ${dmg} ÂÇ∑ÂÆ≥„ÄÇ`, "hit");
                                        let counterTriggered = false;
                                        Object.values(equipped).forEach(item => {
                                            if (item && item.effects) {
                                                item.effects.forEach(eff => {
                                                    if (eff.type === 'counter') {
                                                        const chance = eff.val || 0.2;
                                                        if (Math.random() < chance) {
                                                            counterTriggered = true;
                                                            const counterDmg = Math.floor((player.atk || 10) * 0.8); 
                                                            const newEnemyHp = Math.max(0, enemy.hp - counterDmg);
                                                            enemy = { ...enemy, hp: newEnemyHp };
                                                            currentEnemiesState[i] = enemy;
                                                            setEnemies(prev => prev.map(e => e.uid === enemy.uid ? enemy : e));
                                                            addDamage(counterDmg, 'enemy', false, false, enemy.uid);
                                                            addLog(`‚ö° [${item.name}] Ëß∏ÁôºÂèçÊìäÔºÅÂ∞ç ${enemy.name} ÈÄ†Êàê ${counterDmg} ÂÇ∑ÂÆ≥ÔºÅ`, "special");
                                                        }
                                                    }
                                                });
                                            }
                                        });
                                        if (enemy.hp <= 0) {
                                            await sleep(1200); 
                                            if (currentEnemiesState.every(e => e.hp <= 0)) {
                                                handleVictory();
                                                return;
                                            }
                                            continue; 
                                        }
                                    }
                                    if (totalDamageToPlayer > 0) {
                                        addDamage(totalDamageToPlayer, 'player', false, false);
                                        setPlayerBase(prev => ({ ...prev, hp: Math.max(0, prev.hp - totalDamageToPlayer) }));
                                    }
                                    setActiveEnemyUid(null); 
                                    await sleep(500);
                                    if (currentEnemiesState.every(e => e.hp <= 0)) break;
                                }
                                setCombatStep(0);
                                setTurnLock(false); 
                                setTurnCount(prev => prev + 1);
                                setPlayerBlessedTurns(prev => Math.max(0, prev - 1)); 
                                if (currentEnemiesState.every(e => e.hp <= 0)) {
                                    await sleep(1200); 
                                    handleVictory();
                                }
                            } finally {
                                turnProcessing.current = false;
                            }
                        };
                        processEnemyTurns();
                    }
                } else if (gameState === 'combat' && !needsResume) {
                    if (player.hp <= 0) {
                        setTimeout(() => {
                            showModal({
                                type: 'gameover',
                                title: "ÂÜíÈö™Â§±Êïó",
                                msg: "ÁöÆÂç°‰∏òÂ∑≤Á∂ìÂäõÁ´≠ÂÄí‰∏ã...",
                                onConfirm: () => { closeModal(); setView('menu'); }
                            });
                        }, 500);
                    } 
                }
            }, [gameState, combatStep, enemies, player.hp, player.crit, player.evade, needsResume, player.atk, equipped, day, player.def]);

            const handleVictory = () => {
                if (victoryProcessing.current) return;
                victoryProcessing.current = true;
                setTurnLock(false);
                setIsAutoAttack(false); 
                setHasWarnedNoPotion(false); 
                const expGain = 40 + day * 5;
                const goldGain = 50 + Math.floor(Math.random() * 50); 
                setPlayerBase(prev => {
                    const newKills = (prev.stats?.kills || 0) + enemies.length;
                    const newTotalGold = (prev.stats?.totalGold || 0) + goldGain;
                    return {
                        ...prev,
                        gold: prev.gold + goldGain,
                        stats: { ...prev.stats, kills: newKills, totalGold: newTotalGold }
                    };
                });
                addLog(`‚ú® Êà∞È¨•ÂãùÂà©ÔºÅÁç≤Âæó‰∫Ü ${expGain} Á∂ìÈ©óÂÄºËàá ${goldGain} ÈáëÂπ£„ÄÇ`, "success");
                const maxRank = Math.max(...enemies.map(e => e.rank || 0));
                const isEliteOrBoss = maxRank >= 1;
                const dropChance = isEliteOrBoss ? 0.7 : 0.25;
                if (Math.random() < dropChance) {
                    let newItem = generateScaledItem(ITEM_POOL[Math.floor(Math.random() * ITEM_POOL.length)], day, player.level, isEliteOrBoss);
                    setInventory(prev => [...prev, newItem]);
                    setNewItems(prev => [...prev, newItem.uid]);
                    const isLeg = newItem.rarity === 'Legendary';
                    const isRare = newItem.rarity === 'Rare';
                    let effectText = '';
                    if (newItem.effects && newItem.effects.length > 0) {
                        effectText = ` (Â±¨ÊÄß: ${newItem.effects.map(e => e.name).join(', ')})`;
                    }
                    const bossText = isLeg ? 'üåü ÂÇ≥Ë™™ÈôçËá®ÔºÅ' : isEliteOrBoss ? 'üëë Êà∞Âà©ÂìÅÔºÅ' : 'üéÅ È©öÂñúÔºÅ';
                    const rarityColor = getRarityColor(newItem.rarity);
                    const rarityLabel = isLeg ? 'ÂÇ≥Ë™™' : isRare ? 'Á®ÄÊúâ' : 'ÊôÆÈÄö';
                    const slotName = SLOT_MAP[newItem.slot];
                    addLog(
                        <span>
                            {bossText}ÁôºÁèæ <span className="text-slate-400 font-bold">({slotName})</span> <span className={`${rarityColor} font-bold`}>{rarityLabel}</span> <span className={rarityColor}>[Lv.{newItem.level} {newItem.name}]</span>{effectText}ÔºÅ
                        </span>, 
                        isLeg ? "special" : "success"
                    );
                }
                grantExp(expGain);
                if (gameState !== 'levelup') { 
                    setGameState('idle'); 
                }
                setEnemies([]);
                setCombatStep(0);
                victoryProcessing.current = false;
                interactionLock.current = false;
            };

            const handleRun = () => {
                if (combatStep !== 0 || interactionLock.current) return;
                setTurnLock(true); 
                const isSuccess = Math.random() < 0.5;
                if (isSuccess) {
                    addLog("üí® ÁöÆÂç°‰∏òÊàêÂäüÈÄÉÈõ¢‰∫ÜÊà∞È¨•ÔºÅ", "success");
                    setGameState('idle');
                    setEnemies([]);
                    setCombatStep(0);
                    setTurnLock(false); 
                    setIsAutoAttack(false); 
                } else {
                    addLog("üö´ ÈÄÉË∑ëÂ§±ÊïóÔºÅË¢´Êïµ‰∫∫Êîî‰Ωè‰∫Ü„ÄÇ", "danger");
                    setCombatStep(1);
                }
            };

            const openDayReward = (currentDay) => {
                const numRewards = 3;
                const obtained = [];
                const applyReward = (item) => {
                    if (item.id === 'shop_1') { setPlayerBase(p => ({...p, potions: p.potions + 1})); return { name: "Â§ßÁì∂ÁîüÂëΩËó•Ê∞¥", icon: "Coffee", desc: "Ëó•Ê∞¥ +1" }; }
                    if (item.id === 'shop_6') { setPlayerBase(p => ({...p, paralyzePotions: p.paralyzePotions + 1})); return { name: "È∫ªÁó∫Ëó•Ê∞¥", icon: "Zap", desc: "Ëó•Ê∞¥ +1" }; }
                    if (item.id === 'shop_7') { setPlayerBase(p => ({...p, doublePotions: p.doublePotions + 1})); return { name: "ÈÄ£ÊìäËó•Ê∞¥", icon: "Swords", desc: "Ëó•Ê∞¥ +1" }; }
                    if (item.type === 'chest') { 
                        let pool = ITEM_POOL;
                        if (item.chestType === 'weapon') pool = ITEM_POOL.filter(i => i.slot === 'weapon');
                        else if (item.chestType === 'armor') pool = ITEM_POOL.filter(i => ['head', 'body', 'shoes'].includes(i.slot));
                        else if (item.chestType === 'accessory') pool = ITEM_POOL.filter(i => i.slot === 'ring' || i.slot === 'trinket');
                        let newItem = generateScaledItem(pool[Math.floor(Math.random() * pool.length)], day, playerBase.level);
                        setInventory(prev => [...prev, newItem]);
                        setNewItems(prev => [...prev, newItem.uid]);
                        return { name: item.name.replace('ÁÆ±',''), icon: "Box", desc: `Lv.${newItem.level} {newItem.name}` };
                    }
                    return null;
                };
                for(let i=0; i<numRewards; i++) {
                    const randomItem = SHOP_ITEMS[Math.floor(Math.random() * SHOP_ITEMS.length)];
                    const result = applyReward(randomItem);
                    if (result) obtained.push(result);
                    else i--; 
                }
                showModal({ type: 'day_reward', day: currentDay, rewards: obtained });
            };

            const handleItemClick = (item, source) => {
                if (!item) return;
                if (upgradeTarget) {
                    if (source === 'equipped') return;
                    if (item.uid === upgradeTarget.uid) return;
                    toggleFodder(item.uid);
                } else {
                    if (newItems.includes(item.uid)) {
                        setNewItems(prev => prev.filter(id => id !== item.uid));
                    }
                    const slotName = SLOT_MAP[item.slot];
                    const rarityColor = getRarityColor(item.rarity);
                    if (source === 'inventory') {
                        const slot = item.slot;
                        const prev = equipped[slot];
                        setEquipped(e => ({ ...e, [slot]: item }));
                        setInventory(i => {
                            const filtered = i.filter(x => x.uid !== item.uid);
                            return prev ? [...filtered, prev] : filtered;
                        });
                        setHighlightedSlot(slot);
                        setTimeout(() => setHighlightedSlot(prev => prev === slot ? null : prev), 2000);
                        addLog(<span>üõ°Ô∏è Ë£ùÂÇô‰∫Ü <span className="text-slate-400 font-bold">({slotName})</span> <span className={`${rarityColor} font-bold`}>[Lv.{item.level} {item.name}]</span>„ÄÇ</span>, "system");
                    } else {
                        const slot = item.slot;
                        setEquipped(e => ({ ...e, [slot]: null }));
                        setInventory(i => {
                            if (i.some(existing => existing.uid === item.uid)) return i; 
                            return [...i, item];
                        });
                        addLog(<span>üì¶ ËÑ´‰∏ã‰∫Ü <span className="text-slate-400 font-bold">({slotName})</span> <span className={`${rarityColor} font-bold`}>[Lv.{item.level} {item.name}]</span>„ÄÇ</span>, "system");
                    }
                }
            };

            const handleQuickUpgrade = (e, item) => {
                e.stopPropagation();
                setUpgradeTarget(item);
                setFodderIds([]);
                const slotTabMap = {
                    'weapon': 'Weapon', 'head': 'Head', 'body': 'Body',
                    'ring': 'Ring', 'trinket': 'Trinket', 'shoes': 'Shoes'
                };
                setInventoryTab(slotTabMap[item.slot] || 'All');
            };

            const handleQuickSell = (e, item) => {
                e.stopPropagation();
                const isEquipped = Object.values(equipped).some(e => e && e.uid === item.uid);
                if (isEquipped) {
                    alert("Ë´ãÂÖàËÑ´‰∏ãË£ùÂÇôÂÜçÈÄ≤Ë°åË≤©Ë≥£ÔºÅ");
                    return;
                }
                const sellValue = Math.floor((item.price || 100) * 0.5);
                showModal({
                    type: 'confirm', title: 'ÂõûÊî∂Á¢∫Ë™ç', msg: `Á¢∫ÂÆöË¶ÅÂõûÊî∂ [${item.name}] ÂóéÔºüÂ∞áÁç≤Âæó ${sellValue} ÈáëÂπ£„ÄÇ`,
                    onConfirm: () => {
                        setPlayerBase(p => ({ ...p, gold: p.gold + sellValue }));
                        setInventory(prev => prev.filter(i => i.uid !== item.uid));
                        closeModal();
                        showObtainedToast(`Áç≤Âæó ${sellValue} ÈáëÂπ£`, "Coins");
                    }
                });
            };

            const toggleFodder = (uid) => {
                if (!upgradeTarget) return;
                setFodderIds(prev => prev.includes(uid) ? prev.filter(id => id !== uid) : [...prev, uid]);
            };

            const executeUpgrade = () => {
                if (!upgradeTarget || fodderIds.length === 0) return;
                const costPerItem = 80;
                const totalCost = fodderIds.length * costPerItem;
                if (player.gold < totalCost) {
                    showObtainedToast("ÈáëÂπ£‰∏çË∂≥", "Coins");
                    return;
                }
                const fodderItems = inventory.filter(i => fodderIds.includes(i.uid));
                const totalExp = fodderItems.reduce((acc, item) => acc + getFodderExp(item, upgradeTarget.slot), 0);
                let newItem = { ...upgradeTarget };
                newItem.exp += totalExp;
                while (newItem.exp >= getExpReq(newItem.level)) {
                    newItem.exp -= getExpReq(newItem.level);
                    newItem.level += 1;
                }
                setPlayerBase(p => ({ 
                    ...p, 
                    gold: p.gold - totalCost,
                    stats: { ...p.stats, upgrades: (p.stats.upgrades || 0) + 1 } 
                }));
                setInventory(prev => {
                    const remaining = prev.filter(i => !fodderIds.includes(i.uid) && i.uid !== newItem.uid);
                    const wasInInventory = prev.some(i => i.uid === newItem.uid);
                    return wasInInventory ? [...remaining, newItem] : remaining;
                });
                const slot = newItem.slot;
                if (equipped[slot] && equipped[slot]?.uid === newItem.uid) {
                    setEquipped(e => ({ ...e, [slot]: newItem }));
                }
                addLog(`üî® Âº∑ÂåñÊàêÂäüÔºÅ[${newItem.name}] ÊèêÂçáËá≥ Lv.${newItem.level} (Ê∂àËÄó ${totalCost} G)„ÄÇ`, "special");
                showObtainedToast("Âº∑ÂåñÊàêÂäü", "Hammer");
                setUpgradeTarget(newItem);
                setFodderIds([]);
            };

            const confirmPurchase = () => {
                if (!modal) return;
                const { item, qty } = modal;
                const total = item.price * qty;
                setPlayerBase(p => ({ ...p, gold: p.gold - total }));
                if (item.type === 'consumable') {
                    if (item.id === 'shop_1') setPlayerBase(p => ({...p, potions: p.potions + qty}));
                    if (item.id === 'shop_6') setPlayerBase(p => ({...p, paralyzePotions: (p.paralyzePotions||0) + qty}));
                    if (item.id === 'shop_7') setPlayerBase(p => ({...p, doublePotions: (p.doublePotions||0) + qty}));
                    showObtainedToast(`Ë≥ºË≤∑‰∫Ü ${qty} ÂÄã ${item.name}`, "Coins");
                } else if (item.type === 'chest') {
                    let pool = ITEM_POOL;
                    if (item.chestType === 'weapon') pool = ITEM_POOL.filter(i => i.slot === 'weapon');
                    else if (item.chestType === 'armor') pool = ITEM_POOL.filter(i => ['head', 'body', 'shoes'].includes(i.slot));
                    else if (item.chestType === 'accessory') pool = ITEM_POOL.filter(i => i.slot === 'ring' || i.slot === 'trinket');
                    for(let k=0; k<qty; k++) {
                        let newItem = generateScaledItem(pool[Math.floor(Math.random() * pool.length)], day, playerBase.level);
                        setInventory(prev => [...prev, newItem]);
                        setNewItems(prev => [...prev, newItem.uid]);
                    }
                    showObtainedToast(`ÈñãÂïü‰∫Ü ${qty} ÂÄã ${item.name}`, "Box");
                }
                closeModal();
            };

            const handleCaveDecision = (enter) => {
                closeModal();
                if (!enter) {
                    addLog(`Á¨¨ ${day} Â§©ÔºöÁöÆÂç°‰∏òÊ±∫ÂÆöÁπûÈÅéÁ•ûÁßòÊ¥ûÁ©¥ÔºåÂÆâÂÖ®Á¨¨‰∏Ä„ÄÇ`, "info");
                    setGameState('idle');
                    return;
                }
                const outcome = Math.random();
                const dailyExp = 15 + day * 2;
                if (outcome < 0.4) { 
                    const minPct = 0.15;
                    const maxPct = 0.30;
                    const dmgPct = minPct + Math.random() * (maxPct - minPct);
                    const dmg = Math.max(1, Math.floor(player.hp * dmgPct));
                    const actualDmg = player.hp - dmg <= 0 ? player.hp - 1 : dmg;
                    if (actualDmg > 0) {
                        setPlayerBase(p => ({ ...p, hp: p.hp - actualDmg }));
                        addDamage(actualDmg, 'player', false, false);
                        addLog(`üí• Ê¥ûÁ©¥Á™ÅÁÑ∂Â¥©Â°åÔºÅË¢´ËêΩÁü≥Êìä‰∏≠ÂèóÂà∞ ${actualDmg} ÈªûÂÇ∑ÂÆ≥ÔºÅ`, "danger");
                        showObtainedToast(`Â¥©Â°åÂÇ∑ÂÆ≥ -${actualDmg}`, "Hammer"); 
                    }
                    grantExp(Math.floor(dailyExp/2));
                } else { 
                    const rewardType = Math.random();
                    if (rewardType < 0.4) { 
                        const gold = Math.floor(500 + Math.random() * 301);
                        setPlayerBase(p => ({ ...p, gold: p.gold + gold, stats: {...p.stats, totalGold: (p.stats.totalGold || 0) + gold} }));
                        addLog(`üí∞ Ê¥ûÁ©¥Ê∑±ËôïÁôºÁèæÂè§‰ª£ÈáëÂπ£Â†ÜÔºÅÁç≤Âæó ${gold} ÈáëÂπ£„ÄÇ`, "success");
                        showObtainedToast(`Áç≤Âæó ${gold} ÈáëÂπ£`, "Coins");
                    } else if (rewardType < 0.7) { 
                        const potionType = Math.random();
                        if (potionType < 0.5) {
                            setPlayerBase(p => ({ ...p, potions: p.potions + 1 }));
                            addLog(`üß™ Âú®Á•≠Â£á‰∏äÁôºÁèæ‰∫Ü‰∏ÄÁì∂ÁîüÂëΩËó•Ê∞¥ÔºÅ`, "success");
                            showObtainedToast("Áç≤ÂæóÁîüÂëΩËó•Ê∞¥", "Coffee");
                        } else {
                            setPlayerBase(p => ({ ...p, doublePotions: p.doublePotions + 1 }));
                            addLog(`‚öîÔ∏è ÁôºÁèæ‰∫Ü‰∏ÄÁì∂Á®ÄÊúâÁöÑÈÄ£ÊìäËó•Ê∞¥ÔºÅ`, "success");
                            showObtainedToast("Áç≤ÂæóÈÄ£ÊìäËó•Ê∞¥", "Swords");
                        }
                    } else { 
                        let newItem = generateScaledItem(ITEM_POOL[Math.floor(Math.random() * ITEM_POOL.length)], day, player.level);
                        setInventory(prev => [...prev, newItem]);
                        setNewItems(prev => [...prev, newItem.uid]);
                        const rarityColor = getRarityColor(newItem.rarity);
                        addLog(<span>üíé ÁôºÁèæÈö±ËóèÂØ∂ÁÆ±ÔºÅÁç≤Âæó <span className={`${rarityColor} font-bold`}>[Lv.{newItem.level} {newItem.name}]</span>ÔºÅ</span>, "special");
                        showObtainedToast("ÁôºÁèæÁ®ÄÊúâÂØ∂Ëóè", "Box");
                    }
                    grantExp(dailyExp);
                }
                setGameState('idle');
            };

            const handleStatChange = (stat, delta) => {
                setModal(prev => {
                    if (!prev || prev.type !== 'stat_allocation') return prev;
                    if (delta > 0 && prev.tempPoints > 0) {
                        return { ...prev, tempAllocated: { ...prev.tempAllocated, [stat]: prev.tempAllocated[stat] + 1 }, tempPoints: prev.tempPoints - 1 };
                    } else if (delta < 0 && prev.tempAllocated[stat] > 0) {
                        return { ...prev, tempAllocated: { ...prev.tempAllocated, [stat]: prev.tempAllocated[stat] - 1 }, tempPoints: prev.tempPoints + 1 };
                    }
                    return prev;
                });
            };

            const resetStats = () => {
                setModal(prev => {
                    if (!prev) return null;
                    const totalAllocated = Object.values(playerBase.allocated).reduce((a, b) => a + b, 0);
                    const totalPoints = playerBase.statPoints + totalAllocated;
                    return { ...prev, tempAllocated: { atk: 0, def: 0, hp: 0 }, tempPoints: totalPoints }
                });
                showObtainedToast(`Â±¨ÊÄßÂ∑≤ÈáçÁΩÆ`, "History");
            };

            const confirmStats = () => {
                if (!modal) return;
                setPlayerBase(prev => ({
                    ...prev,
                    allocated: modal.tempAllocated,
                    statPoints: modal.tempPoints
                }));
                closeModal();
                showObtainedToast("Â±¨ÊÄßÊõ¥Êñ∞", "Check");
            };

            const handleBackupRestore = () => showModal({ type: 'data_transfer', mode: 'menu' });

            const handleDeleteSave = (e) => {
                e.stopPropagation();
                showModal({
                    type: 'confirm',
                    title: 'Âà™Èô§Á¥ÄÈåÑ',
                    msg: 'Á¢∫ÂÆöË¶ÅÂà™Èô§ÂÜíÈö™Á¥ÄÈåÑÂóéÔºüÊ≠§Âãï‰ΩúÁÑ°Ê≥ïÂæ©Âéü„ÄÇ',
                    onConfirm: () => {
                        safeLocalStorage.removeItem('pikachu_save');
                        setHasSave(false);
                        closeModal();
                        showObtainedToast("Á¥ÄÈåÑÂ∑≤Âà™Èô§", "Trash");
                    }
                });
            };

            const getExportData = () => {
                try {
                    let dataStr = safeLocalStorage.getItem('pikachu_save');
                    if (!dataStr && hasSave) dataStr = JSON.stringify(getSaveObject());
                    if(!dataStr) return null;
                    return btoa(unescape(encodeURIComponent(dataStr)));
                } catch(e) { return null; }
            };

            const handleCopySaveToClipboard = () => {
                const dataStr = getExportData();
                if (!dataStr) {
                    alert("ÁÑ°Ê≥ïÁî¢ÁîüÂ≠òÊ™î‰ª£Á¢ºÔºåË´ãÁ¢∫Ë™çÊòØÂê¶Â∑≤ÊúâÈÅäÊà≤ÈÄ≤Â∫¶„ÄÇ");
                    return;
                }
                navigator.clipboard.writeText(dataStr).then(() => {
                    showObtainedToast("Â≠òÊ™î‰ª£Á¢ºÂ∑≤Ë§áË£Ω", "Copy");
                }, () => {
                    alert("Ë§áË£ΩÂ§±ÊïóÔºåË´ãÊâãÂãïË§áË£Ω„ÄÇ");
                });
            };

            const downloadSaveFile = () => {
                const dataStr = getExportData();
                if (!dataStr) {
                    alert("ÁÑ°Ê≥ïÁî¢ÁîüÂ≠òÊ™îË≥áÊñôÔºåË´ãÁ¢∫Ë™çÊòØÂê¶Â∑≤ÊúâÈÅäÊà≤ÈÄ≤Â∫¶„ÄÇ");
                    return;
                }
                const blob = new Blob([dataStr], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                const date = new Date().toISOString().slice(0, 10);
                a.download = `Pikachu_Save_Day${day}_${date}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showObtainedToast("Â≠òÊ™îÂ∑≤‰∏ãËºâ", "Save");
            };

            const handleFileImport = (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => handleImportData(e.target?.result);
                reader.readAsText(file);
                event.target.value = '';
            };

            const handleImportData = (code) => {
                try {
                    const json = decodeURIComponent(escape(atob(code)));
                    const data = JSON.parse(json);
                    if(data && data.playerBase) {
                        safeLocalStorage.setItem('pikachu_save', json);
                        setHasSave(true);
                        closeModal();
                        showObtainedToast("Â≠òÊ™îÂåØÂÖ•ÊàêÂäü", "Check");
                        setTimeout(() => loadGame(), 500);
                    } else {
                        alert("ÁÑ°ÊïàÁöÑÂ≠òÊ™îÊ™îÊ°àÔºÅÂÖßÂÆπÊ†ºÂºè‰∏çÁ¨¶„ÄÇ");
                    }
                } catch(e) {
                    alert("Ê™îÊ°àËÆÄÂèñÂ§±ÊïóÔºÅË´ãÁ¢∫Ë™çÈÄôÊòØÊúâÊïàÁöÑÁöÆÂç°‰∏òÂ§ßÂÜíÈö™Â≠òÊ™î„ÄÇ");
                }
            };

            return (
                <div className="game-wrapper">
                    <div className="phone-screen shadow-2xl habby-shadow" style={{ transform: `scale(${scale})` }}>
                        {view === 'menu' ? (
                            <GameMenu 
                                hasSave={hasSave}
                                onLoad={loadGame}
                                onReset={resetGame}
                                onDeleteSave={handleDeleteSave}
                                onBackupRestore={handleBackupRestore}
                            />
                        ) : (
                            <React.Fragment>
                                <Header 
                                    player={player}
                                    isAutoAttack={isAutoAttack}
                                    autoSave={autoSave}
                                    setAutoSave={setAutoSave}
                                    setView={setView}
                                    showModal={showModal}
                                    saveGame={saveGame}
                                    setNewItems={setNewItems}
                                />
                                <StatusPanel 
                                    player={player}
                                    playerDoubleStrikeTurns={playerDoubleStrikeTurns}
                                    playerBlessedTurns={playerBlessedTurns}
                                />
                                <AdventureScene 
                                    gameState={gameState}
                                    enemies={enemies}
                                    player={player}
                                    damages={damages}
                                    needsResume={needsResume}
                                    setNeedsResume={setNeedsResume}
                                    activeEnemyUid={activeEnemyUid}
                                    playerAction={playerAction}
                                />
                                <GameLogs 
                                    logs={logs}
                                    day={day}
                                    enemies={enemies}
                                />
                                <ControlPanel 
                                    gameState={gameState}
                                    needsResume={needsResume}
                                    combatStep={combatStep}
                                    playerAction={playerAction}
                                    turnLock={turnLock}
                                    isAutoAttack={isAutoAttack}
                                    isAutoAdventure={isAutoAdventure}
                                    setIsAutoAttack={setIsAutoAttack}
                                    setIsAutoAdventure={setIsAutoAdventure}
                                    handlePlayerAttack={handlePlayerAttack}
                                    handleRun={handleRun}
                                    handleNextStep={handleNextStep}
                                    setView={setView}
                                    setInventoryTab={setInventoryTab}
                                    playerBase={playerBase}
                                    usePotion={usePotion}
                                    setAutoPotionEnabled={setAutoPotionEnabled}
                                    autoPotionEnabled={autoPotionEnabled}
                                />
                            </React.Fragment>
                        )}
                        
                        {view === 'inventory' && (
                            <InventoryView 
                                inventory={inventory}
                                equipped={equipped}
                                player={player}
                                upgradeTarget={upgradeTarget}
                                fodderIds={fodderIds}
                                newItems={newItems}
                                inventoryTab={inventoryTab}
                                highlightedSlot={highlightedSlot}
                                setUpgradeTarget={setUpgradeTarget}
                                setFodderIds={setFodderIds}
                                setInventoryTab={setInventoryTab}
                                setView={setView}
                                setNewItems={setNewItems}
                                handleItemClick={handleItemClick}
                                handleQuickUpgrade={handleQuickUpgrade}
                                handleQuickSell={handleQuickSell}
                                executeUpgrade={executeUpgrade}
                                toggleFodder={toggleFodder}
                                showModal={showModal}
                                playerBase={playerBase}
                                filteredInventory={filteredInventory}
                            />
                        )}
                        {view === 'shop' && (
                            <ShopView 
                                player={player}
                                setView={setView}
                                showModal={showModal}
                            />
                        )}
                        
                        {modal && (
                            <ModalManager 
                                modal={modal}
                                player={player}
                                closeModal={closeModal}
                                setModal={setModal}
                                confirmPurchase={confirmPurchase}
                                handleStatChange={handleStatChange}
                                resetStats={resetStats}
                                confirmStats={confirmStats}
                                setPlayerBase={setPlayerBase}
                                handleCaveDecision={handleCaveDecision}
                                downloadSaveFile={downloadSaveFile}
                                handleFileImport={handleFileImport}
                                handleLevelUpChoice={handleLevelUpChoice}
                                levelUpOptions={levelUpOptions}
                                handleCopySaveToClipboard={handleCopySaveToClipboard}
                                handleImportData={handleImportData}
                            />
                        )}
                        
                        {toast && (
                                <div className="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-[60] obtained-toast flex flex-col items-center pointer-events-none">
                                <div className="bg-black/80 text-white px-6 py-4 rounded-2xl backdrop-blur-md shadow-xl flex flex-col items-center gap-2 border border-white/20">
                                    {toast.icon && <Icon name={toast.icon} size={32} className="text-amber-400 mb-1" />}
                                    <div className="font-black text-lg text-center">{toast.text}</div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>